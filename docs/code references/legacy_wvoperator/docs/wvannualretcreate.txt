FOXPRO CODE



*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="wvannualretcreate.scx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />

	*<PropValue>
		AutoOpenTables = .F.
		DataSource = .NULL.
		Height = 717
		Left = 361
		Name = "Dataenvironment"
		Top = 72
		Width = 767
	*</PropValue>

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "fields", ;
		CursorSource = "fields", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor10", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor11", ;
		Top = 380, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 404, ;
		Name = "Cursor12", ;
		Top = 261, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "suspense", ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor13", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "ownpcts", ;
		CursorSource = "ownpcts", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 559, ;
		Name = "Cursor14", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "annprod1", ;
		CursorSource = "annprod", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor15", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "appurchd", ;
		CursorSource = "appurchd", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 580, ;
		Name = "Cursor16", ;
		Top = 393, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "appurchh", ;
		CursorSource = "appurchh", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 575, ;
		Name = "Cursor17", ;
		Top = 139, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "stateaccounts", ;
		CursorSource = "stateaccounts", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 448, ;
		Name = "Cursor18", ;
		Top = 420, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "wellhist", ;
		CursorSource = "wellhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "welldays", ;
		CursorSource = "welldays", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "annprod", ;
		BufferModeOverride = 5, ;
		CursorSource = "annprod", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "form6s", ;
		BufferModeOverride = 5, ;
		CursorSource = "form6s", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 396, ;
		Name = "Cursor7", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "revsrc", ;
		CursorSource = "revsrc", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 399, ;
		Name = "Cursor9", ;
		Top = 141, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formwvannualretcreate AS frmformcustom OF "..\..\..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblBuildYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBuild" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseProducer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseOverride" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkExpenses" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: buildfile
		*m: buildpadata		&& Gets the PA waste and disposal data for a Particular PA well
		*m: build_ny		&& Builds the NY Annual return file
		*m: build_oh		&& Builds the Ohio Form 10 file
		*m: build_pa		&& Builds the PA waste water return
		*m: build_wv		&& Builds WV Annual Return File
		*m: build_wv_owners
		*p: cstate
		*p: ctaxyear
		*a: astates[1,0]		&& Array of available states to report on.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "Create WV Producer/Operator Return"
		ctaxyear = 
		DataSession = 2
		DoCreate = .T.
		Height = 440
		HelpContextID = 602
		Name = "FormWVAnnualRetCreate"
		Width = 608
		_memberdata = <VFPData>
			<memberdata name="buildpadata" display="BuildPaData"/>
			<memberdata name="build_wv" display="Build_WV"/>
			<memberdata name="build_pa" display="Build_PA"/>
			<memberdata name="build_oh" display="Build_OH"/>
			<memberdata name="build_ny" display="Build_NY"/>
			<memberdata name="ctaxyear" display="cTaxYear"/>
			<memberdata name="build_wv_owners" display="Build_WV_Owners"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkExpenses' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Assume $5,000 Expense Safe Harbor Instead of Using Actual Expenses", ;
		Left = 156, ;
		Name = "chkExpenses", ;
		TabIndex = 6, ;
		Top = 191, ;
		Value = .T., ;
		Visible = .T., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUseOverride' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = 'Report Overriding Royalty Under "Override Interest"', ;
		Left = 156, ;
		Name = "chkUseOverride", ;
		TabIndex = 8, ;
		Top = 264, ;
		Value = .F., ;
		Visible = .F., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUseProducer' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Report Working Interest Under Producer Name", ;
		Left = 156, ;
		Name = "chkUseProducer", ;
		TabIndex = 7, ;
		Top = 228, ;
		Value = .F., ;
		Visible = .F., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdBuild' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Build File", ;
		Default = .T., ;
		Height = 60, ;
		Left = 180, ;
		Name = "cmdBuild", ;
		TabIndex = 9, ;
		Top = 348, ;
		Width = 99, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 60, ;
		Left = 312, ;
		Name = "cmdExit", ;
		TabIndex = 10, ;
		Top = 348, ;
		Width = 99, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblBuildYear' AS lbllabelcustom WITH ;
		Caption = "Year", ;
		Height = 16, ;
		Left = 156, ;
		Name = "lblBuildYear", ;
		TabIndex = 4, ;
		Top = 119, ;
		Width = 26, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Base File On:", ;
		Left = 156, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 2, ;
		Top = 31, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgYear' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 47, ;
		Left = 236, ;
		Name = "opgYear", ;
		TabIndex = 1, ;
		Top = 24, ;
		Width = 110, ;
		ZOrderSet = 5, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Accounting Year", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Width = 100, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Production Year", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 26, ;
		Option2.Width = 96
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtcYear' AS txttextboxcustom WITH ;
		Height = 20, ;
		InputMask = "XXXX", ;
		Left = 236, ;
		MaxLength = 4, ;
		Name = "txtcYear", ;
		TabIndex = 3, ;
		Top = 117, ;
		Width = 39, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE buildfile
		LOCAL lnReportOn, ldDate1, ldDate2, llActive, lnCount, lnRecords, lcState, llCompress, lnMultiplier
		LOCAL lnDays, llLeapYr, cTaxYear, cOwnerNo, llUseProducer_for_Working, lcWorkint, llOverride, lnTally
		LOCAL lcWhereW, llDays, llNoProd, llPACodes, llReturn, lnBBLs, lnGasInt, lnMax, lnOilInt, lnTotGas
		LOCAL lnTotOil, lnX, lnpct, loError, oProgress, m.cyear
		
		llReturn = .T.
		
		TRY
		    SET TALK OFF
		    lnDecimal = SET('Decimals')
		    SET DECIMALS TO 8
		
		    STORE .F. TO llUseProducer_for_Working, llOverride
		    STORE ' ' TO lcWorkint
		    lnCount      = 0
		    lnRecords    = 0
		    lcState      = THISFORM.cstate
		    m.cwellstate = lcState
		    m.cyear      = ALLTRIM(THISFORM.txtcYear.VALUE)
		
		    m.cTaxYear   = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		    llActive     = .F.
		    ldDate1      = DATE()
		    ldDate2      = DATE()
		    lnReportOn   = THISFORM.opgYear.VALUE
		    llNoProd     = .T.
		    llCompress   = .F.
		    lnMultiplier = IIF(llCompress, 1, 0)
		
		* Look for missing nra numbers
		    llReturn = wvmissingnras(THISFORM.DATASESSIONID)
		    IF NOT llReturn AND MESSAGEBOX('Do you want to create the WV annual return file for only the wells that have NRA numbers?',36,'Missing NRAs Continue?') = 7
		        EXIT
		    ENDIF
		
		    SELECT annprod
		    COUNT FOR cyear = m.cyear AND cwellstate = lcState TO lnCount
		    IF lnCount > 0
		        IF NOT THISFORM.oMessage.CONFIRM('Production data already exists for ' + m.cyear + ' Do you want to overwrite it?')
		            WAIT WIND NOWAIT 'File Create Cancelled.'
		            lReturn = .F.
		            EXIT
		        ELSE
		            DELETE FOR cyear = m.cyear AND cwellstate = lcState
		            IF lcState = 'WV'
		                SELECT form6s
		                DELETE FOR cyear = m.cyear AND cstate = lcState
		            ENDIF
		        ENDIF
		    ENDIF
		
		&&  Updates the royalty oil and gas percentages in the well record based on the current DOI - Needs run to clean up wells set not to calculate NRI  - BH 7/26/2005
		
		    swclose('revwrk')
		    swselect('wells')
		    swselect('wellinv')
		
		    SELECT  cwellid, SUM(nrevgas) AS lnGasPct, SUM(nrevoil) AS lnOilPct ;
		        FROM wellinv ;
		        INTO CURSOR revwrk ;
		        WHERE INLIST(ctypeinv, 'L', 'O') ;
		        AND NOT DELETED()  ;
		        GROUP BY cwellid
		
		*  Update landowner and override pcts in the well record
		    SELECT revwrk
		    SCAN
		        SELECT wells
		        SET ORDER TO cwellid
		        IF SEEK(revwrk.cwellid)
		            IF nOilInt <> revwrk.lnOilPct
		                REPL nOilInt WITH revwrk.lnOilPct
		            ENDIF
		            IF nGasInt <> revwrk.lnGasPct
		                REPL nGasInt WITH revwrk.lnGasPct
		            ENDIF
		        ENDIF
		    ENDSCAN
		
		    CREATE CURSOR temp ;
		        (cidannp        c(8), ;
		        cwellid        c(10), ;
		        cwellname      c(30), ;
		        cyear          c(4), ;
		        cTaxYear       c(4), ;
		        crptgroup      c(1), ;
		        ctaxid         c(20), ;
		        cwellstatus    c(1),  ;
		        nwellcount     N(5), ;
		        cpermit        c(20), ;
		        ccounty        c(25), ;
		        ctownship      c(25), ;
		        cwvdistrict    c(60), ;
		        cparcel        c(30), ;
		        csection       c(10), ;
		        clot           c(30), ;
		        nacres         N(12, 2), ;
		        nleaseacres    N(12, 2), ;
		        noilbbl        I, ;
		        ngasmcf        I, ;
		        nothbbl        I, ;
		        nmonths        N(2), ;
		        ndayson        N(3), ;
		        dProdDate      d,  ;
		        nsaltbbl       N(7), ;
		        cOwnerNo       c(10), ;
		        crevbbl        c(8), ;
		        cbblpurch      c(30), ;
		        crevmcf        c(8), ;
		        cmcfpurch      c(30), ;
		        cproducer      c(40), ;
		        cagent         c(40), ;
		        caddress       c(40), ;
		        ccity          c(25), ;
		        cwellstate     c(2), ;
		        cstate         c(2), ;
		        czip           c(10), ;
		        ccontact       c(40), ;
		        cfield         c(30), ;
		        cformation     c(30), ;
		        cmeterid       c(4),  ;
		        cmeterserialno c(25), ;
		        cmeterloc      c(25), ;
		        cmetercity     c(40), ;
		        cmeterstate    c(2), ;
		        cmeterzip      c(10), ;
		        ctelephone     c(15), ;
		        cnra           c(20), ;
		        cfacility      c(10), ;
		        cfacpermit     c(10), ;
		        cwastecode     c(5), ;
		        cdispcode      c(4), ;
		        nworkoil       N(12, 2), ;
		        nworkgas       N(12, 2), ;
		        nworkngl       N(12, 2), ;
		        nroyoil        N(12, 2), ;
		        nroygas        N(12, 2), ;
		        nroyngl        N(12, 2), ;
		        noilinc        N(12, 2), ;
		        ngasinc        N(12, 2), ;
		        nothinc        N(12, 2), ;
		        nflatgas       N(12, 2), ;
		        nflatoil       N(12, 2), ;
		        nworkint       N(12, 2), ;
		        noilexpense    N(12,2), ;
		        ngasexpense    N(12,2), ;
		        nothexpense    N(12,2), ;
		        lhousegas      L, ;
		        cqtrtwp        c(10), ;
		        cprodyr        c(4), ;
		        lnglethane     L, ;
		        lnglpropane    L, ;
		        lnglbutane     L, ;
		        lnglisobutane  L, ;
		        lnglpentane    L)
		
		    SET DELETED ON
		
		    DO CASE
		    CASE lnReportOn = 1  &&  Accounting Year
		        lcWhereW  = "YEAR(wellhist.hdate) = VAL(m.cYear)"
		    CASE lnReportOn = 2  &&  Production Year
		        lcWhereW = "wellhist.hyear  = m.cYear"
		    CASE lnReportOn = 3  &&  Accounting Date Range
		        lcWhereW = "BETWEEN(wellhist.hdate, ldDate1, ldDate2)"
		    ENDCASE
		
		    IF llLeapYr
		        lnDays = 366
		        llDays = .T.
		    ELSE
		        lnDays = 365
		        llDays = .T.
		    ENDIF
		
		    llReturn = THISFORM.Build_WV()
		
		    IF NOT llReturn
		        EXIT
		    ENDIF
		
		* Check on the existence of the application object
		* if it doesn't exist, we're running in development
		* mode and need to initialize the company address info.
		
		    IF TYPE('m.goApp') = 'O'
		        swselect('compmast')
		        LOCATE FOR cidcomp = m.goapp.cidcomp
		        IF FOUND()
		            lcCompState = cstate
		        ELSE
		            lcCompState = m.goapp.cstate
		        ENDIF
		        m.cproducer  = m.goapp.ccompanyname
		        m.cagent     = m.goapp.cAgentname
		        m.caddress   = ALLTRIM(m.goapp.cAddress1)
		        m.ctaxid     = m.goapp.ctaxid
		        m.ccity      = m.goapp.ccity
		        m.cstate     = m.goapp.cstate
		        m.czip       = m.goapp.czip
		        m.ccontact   = m.goapp.ccontact
		        m.ctelephone = m.goapp.cPhoneNo
		    ELSE
		        m.cproducer  = 'SherWare, Inc.'
		        m.cagent     = 'SherWare, Inc.'
		        m.caddress   = 'PO Box 223'
		        m.ctaxid     = '99-9999999'
		        m.ccontact   = 'Phil Sherwood'
		        m.ctelephone = '3302623115'
		        m.ccity      = 'Wooster'
		        m.cstate     = 'OH'
		        lcCompState  = 'OH'
		        m.czip       = '44691'
		    ENDIF
		
		    IF NOT USED('wellann1')
		        llReturn = .F.
		        EXIT
		    ENDIF
		
		    SELECT wellann1
		    lnMax = RECC()
		    SELECT wellann2
		    lnMax     = lnMax + RECC()
		    lnCount   = 0
		    lnRecords = 0
		
		    oProgress = THISFORM.oMessage.ProgressBar('Building Annual Statement of Production File For ' + m.cyear)
		    oProgress.SetProgressRange(0, lnMax)
		
		    swselect('land')
		    SET ORDER TO CLEASEID   && CLEASEID
		
		* Plug in the days on and divide the reported amounts among the
		* NRA #s given for the well.
		    SELECT wellann1
		    SCAN
		        SCATTER MEMVAR
		
		        swselect('leasewell')
		        LOCATE FOR cwellid = m.cwellid
		        IF FOUND()
		            m.CLEASEID = CLEASEID
		            swselect('land')
		            IF SEEK(m.CLEASEID)
		                m.nleaseacres = ngrossacre
		            ENDIF
		        ENDIF
		
		        oProgress.UpdateProgress(lnCount)
		        lnCount = lnCount + 1
		        IF m.nwellcount = 0
		            m.nwellcount = 1
		        ENDIF
		        m.cprodyr = TRANSFORM(YEAR(m.dProdDate))
		        IF ALLTRIM(m.cprodyr) = '0'
		            m.cprodyr = ''
		        ENDIF
		        m.crevbbl = crevbbl
		        m.crevmcf = crevmcf
		        IF m.noilbbl + m.ngasmcf + m.nothbbl > 0
		            IF llDays
		* We chose to use the full year (365 or 366 days)
		                IF m.cprodyr < m.cyear OR EMPTY(m.dProdDate)
		* Production started before this year
		* Use the full year as days on
		                    m.ndayson = lnDays
		                ELSE
		* Calculate the days on by subtracting
		* the production begin date from the end
		* of the year
		                    m.ndayson = DATE(VAL(m.cyear), 12, 31) - m.dProdDate
		                ENDIF
		            ELSE
		* We didn't choose to use the full year so use the
		* actual days on unless the days on is zero
		                IF m.ndayson = 0
		* Check to see if we started production this
		* year. If so, calculate the actual days on
		* from the start of production
		                    IF m.cprodyr >= m.cyear AND NOT EMPTY(m.dProdDate)
		                        m.ndayson = DATE(VAL(m.cyear), 12, 31) - m.dProdDate
		                    ELSE
		* Use the full year
		                        m.ndayson = lnDays
		                    ENDIF
		                ENDIF
		            ENDIF
		        ELSE
		* There was no production during the year
		            m.ndayson = 0
		        ENDIF
		        m.nmonths = m.ndayson / 30
		        SELECT revsrc
		        SET ORDER TO crevkey
		        IF SEEK(m.crevbbl)
		            m.cbblpurch = crevname
		        ELSE
		            m.cbblpurch = ' '
		        ENDIF
		        IF SEEK(m.crevmcf)
		            m.cmcfpurch = crevname
		        ELSE
		            m.cmcfpurch = ' '
		        ENDIF
		        lnOilInt = 100 - m.nOilInt
		        lnGasInt = 100 - m.nGasInt
		
		        m.noilbbl = m.noilbbl / m.nwellcount
		        m.ngasmcf = m.ngasmcf / m.nwellcount
		        m.nothbbl = m.nothbbl / m.nwellcount
		        m.noilinc = m.noilinc / m.nwellcount
		        m.ngasinc = m.ngasinc / m.nwellcount
		        m.nothinc = m.nothinc / m.nwellcount
		        m.noilexpense = m.noilexpense / m.nwellcount
		        m.ngasexpense = m.ngasexpense / m.nwellcount
		        m.nothexpense = m.nothexpense / m.nwellcount
		
		
		        STORE 0 TO m.nworkoil, m.nworkgas, m.nworkngl
		        STORE 0 TO m.nroyoil, m.nroygas, m.nroyngl
		
		
		        SELECT disbhist.*, sysctl.dacctdate FROM disbhist, sysctl ;
		            WHERE cwellid = m.cwellid AND ctypeinv = 'W' AND crectype = 'R' ;
		            AND sysctl.crunyear = disbhist.crunyear AND sysctl.nrunno = disbhist.nrunno ;
		            AND sysctl.ctypeclose = 'R' AND sysctl.cgroup = disbhist.cgroup ;
		            INTO CURSOR tempworkhist READWRITE
		
		
		        SELECT disbhist.*, sysctl.dacctdate FROM disbhist, sysctl ;
		            WHERE cwellid = m.cwellid AND ctypeinv # 'W' AND crectype = 'R' ;
		            AND sysctl.crunyear = disbhist.crunyear AND sysctl.nrunno = disbhist.nrunno ;
		            AND sysctl.ctypeclose = 'R' AND sysctl.cgroup = disbhist.cgroup ;
		            INTO CURSOR temproyhist READWRITE
		
		
		        SELECT tempworkhist  &&  Calculate the working interest oil/gas from the amounts actually paid
		*  Since lnReportOn = 1 or 3, we need to look at every W record for this well, and then
		*  check to see whether it came from suspense and match that against sysctl.
		        SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		*  Accounting Year
		            IF lnReportOn = 1
		*  If it didn't come from suspense and the date falls in the right year, include it
		                IF EMPTY(cRunYear_in)
		                    IF TRANSFORM(YEAR(tempworkhist.dacctdate)) <> m.cyear
		                        LOOP
		                    ENDIF
		                ENDIF
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = tempworkhist.nRunNo_In AND crunyear = tempworkhist.cRunYear_in AND ctypeclose = tempworkhist.crectype
		                    IF FOUND()
		                        IF YEAR(sysctl.dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF tempworkhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ENDIF
		                ENDIF
		            ENDIF
		
		*  Production Year
		            IF lnReportOn = 2
		*  By production year doesn't care about suspense.  If it matches, it gets included
		                IF tempworkhist.hyear <> m.cyear
		                    LOOP
		                ENDIF
		            ENDIF
		
		*  Accounting Date Range
		            IF lnReportOn = 3
		*  If it didn't come from suspense and the date falls in the right range, include it
		                IF EMPTY(cRunYear_in) AND NOT BETWEEN(hdate, ldDate1, ldDate2)
		                    LOOP
		                ENDIF
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = tempworkhist.nRunNo_In AND crunyear = tempworkhist.cRunYear_in AND ctypeclose = tempworkhist.crectype
		                    IF FOUND()
		                        IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF tempworkhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ELSE
		                        LOOP
		                    ENDIF
		                ENDIF
		            ENDIF
		
		            m.nworkoil = m.nworkoil + tempworkhist.nOilRev
		            m.nworkgas = m.nworkgas + tempworkhist.nGasRev - ((tempworkhist.nCompress + tempworkhist.nGather) * lnMultiplier)
		            m.nworkngl = m.nworkngl + tempworkhist.nothrev
		        ENDSCAN
		
		
		        SELECT temproyhist  &&  Calculate the Royalty interest oil/gas from the amounts actually paid
		*  Since lnReportOn = 1 or 3, we need to look at every # W record for this well, and then
		*  check to see whether it came from suspense and match that against sysctl.
		        SCAN FOR cwellid = m.cwellid AND ctypeinv # 'W'
		*  Accounting Year
		            IF lnReportOn = 1
		*  If it didn't come from suspense and the date falls in the right year, include it
		                IF EMPTY(cRunYear_in)
		                    IF TRANSFORM(YEAR(temproyhist.dacctdate)) <> m.cyear
		                        LOOP
		                    ENDIF
		                ENDIF
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = temproyhist.nRunNo_In AND crunyear = temproyhist.cRunYear_in AND ctypeclose = temproyhist.crectype
		                    IF FOUND()
		                        IF YEAR(sysctl.dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF temproyhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ENDIF
		                ENDIF
		            ENDIF
		
		*  Production Year
		            IF lnReportOn = 2
		*  By production year doesn't care about suspense.  If it matches, it gets included
		                IF temproyhist.hyear <> m.cyear
		                    LOOP
		                ENDIF
		            ENDIF
		
		*  Accounting Date Range
		            IF lnReportOn = 3
		*  If it didn't come from suspense and the date falls in the right range, include it
		                IF EMPTY(cRunYear_in) AND NOT BETWEEN(hdate, ldDate1, ldDate2)
		                    LOOP
		                ENDIF
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = temproyhist.nRunNo_In AND crunyear = temproyhist.cRunYear_in AND ctypeclose = temproyhist.crectype
		                    IF FOUND()
		                        IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF temproyhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ELSE
		                        LOOP
		                    ENDIF
		                ENDIF
		            ENDIF
		
		            m.nroyoil = m.nroyoil + temproyhist.nOilRev
		            m.nroygas = m.nroygas + temproyhist.nGasRev - ((temproyhist.nCompress + temproyhist.nGather) * lnMultiplier) + temproyhist.nflatrate
		            m.nroyngl = m.nroyngl + temproyhist.nothrev
		        ENDSCAN
		
		
		*  Now on to suspense.  Same basic logic as above.  Check all W records.
		        SELECT suspense
		        SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		
		            IF lnReportOn = 1
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                    IF FOUND()
		                        IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ELSE
		                        LOOP
		                    ENDIF
		                ENDIF
		            ENDIF
		
		*  Production Year
		            IF lnReportOn = 2
		*  By production year doesn't care about suspense dates.  If it matches, it gets included
		                IF suspense.hyear <> m.cyear
		                    LOOP
		                ENDIF
		            ENDIF
		
		*  Accounting Date Range
		            IF lnReportOn = 3
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                    IF FOUND()
		                        IF NOT BETWEEN(sysctl.dacctdate, ldDate1, ldDate2)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ENDIF
		                ENDIF
		            ENDIF
		
		            m.nworkoil = m.nworkoil + suspense.nOilRev
		            m.nworkgas = m.nworkgas + suspense.nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		            m.nworkngl = m.nworkngl + suspense.nothrev
		        ENDSCAN
		
		*  Now on to suspense.  Same basic logic as above.  Check all Royalty records.
		        SELECT suspense
		        SCAN FOR cwellid = m.cwellid AND ctypeinv # 'W'
		
		            IF lnReportOn = 1
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                    IF FOUND()
		                        IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ELSE
		                        LOOP
		                    ENDIF
		                ENDIF
		            ENDIF
		
		*  Production Year
		            IF lnReportOn = 2
		*  By production year doesn't care about suspense dates.  If it matches, it gets included
		                IF suspense.hyear <> m.cyear
		                    LOOP
		                ENDIF
		            ENDIF
		
		*  Accounting Date Range
		            IF lnReportOn = 3
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                IF NOT EMPTY(cRunYear_in)
		                    SELECT sysctl
		                    LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                    IF FOUND()
		                        IF NOT BETWEEN(sysctl.dacctdate, ldDate1, ldDate2)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                            LOOP
		                        ENDIF
		                        IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                            LOOP
		                        ENDIF
		                    ENDIF
		                ENDIF
		            ENDIF
		
		            m.nroyoil = m.nroyoil + suspense.nOilRev
		            m.nroygas = m.nroygas + suspense.nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		            m.nroyngl = m.nroyngl + suspense.nothrev
		        ENDSCAN
		
		        m.nsaltbbl   = m.nsaltbbl / m.nwellcount
		        m.nworkgas   = m.nworkgas / m.nwellcount
		        m.nworkoil   = m.nworkoil / m.nwellcount
		        m.nworkngl   = m.nworkngl / m.nwellcount
		        m.nroygas   = m.nroygas / m.nwellcount
		        m.nroyoil   = m.nroyoil / m.nwellcount
		        m.nroyngl   = m.nroyngl / m.nwellcount
		        m.cfacility  = ''
		        m.cfacpermit = ''
		
		        SELECT wells
		        SET ORDER TO cwellid
		        SEEK(m.cwellid)
		        FOR lnX = 1 TO m.nwellcount
		            DO CASE
		            CASE lnX = 1
		                m.cpermit  = m.cpermit1
		                m.cpermit1 = ' '
		                m.cnra = wells.cnra1
		            CASE lnX = 2
		                m.cpermit  = m.cpermit2
		                m.cpermit2 = ' '
		                m.cnra = wells.cnra2
		            CASE lnX = 3
		                m.cpermit  = m.cpermit3
		                m.cpermit3 = ' '
		                m.cnra = wells.cnra3
		            CASE lnX = 4
		                m.cpermit  = m.cpermit4
		                m.cpermit4 = ' '
		                m.cnra = wells.cnra4
		            CASE lnX = 5
		                m.cpermit  = m.cpermit5
		                m.cpermit5 = ' '
		                m.cnra = wells.cnra5
		            CASE lnX = 6
		                m.cpermit  = m.cpermit6
		                m.cpermit6 = ' '
		                m.cnra = wells.cnra6
		            ENDCASE
		            m.cwellstate = lcState
		            m.crptgroup  = 'A'
		            m.nworkoil   = ROUND(m.nworkoil, 0)
		            m.nworkgas   = ROUND(m.nworkgas, 0)
		            m.nworkngl   = ROUND(m.nworkngl, 0)
		            m.nroyoil   = ROUND(m.nroyoil, 0)
		            m.nroygas   = ROUND(m.nroygas, 0)
		            m.nroyngl   = ROUND(m.nroyngl, 0)
		            m.noilinc    = ROUND(m.noilinc, 0)
		            m.ngasinc    = ROUND(m.ngasinc, 0)
		            m.nothinc    = ROUND(m.nothinc, 0)
		
		
		            m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            SELECT annprod1
		            SET ORDER TO cidannp
		            SET DELETED OFF
		            DO WHILE SEEK(m.cidannp)
		                m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            ENDDO
		            SET DELETED ON
		            m.cstate = lcCompState
		            INSERT INTO temp FROM MEMVAR
		        ENDFOR
		
		    ENDSCAN
		
		    SELECT wellann2
		    IF RECC() > 0
		        SCAN
		            SCATTER MEMVAR
		            oProgress.UpdateProgress(lnCount)
		
		            swselect('leasewell')
		            LOCATE FOR cwellid = m.cwellid
		            IF FOUND()
		                m.CLEASEID = CLEASEID
		                swselect('land')
		                IF SEEK(m.CLEASEID)
		                    m.nleaseacres = ngrossacre
		                ENDIF
		            ENDIF
		
		            lnCount = lnCount + 1
		            IF m.nwellcount = 0
		                m.nwellcount = 1
		            ENDIF
		            lnOilInt  = 100 - m.nOilInt
		            lnGasInt  = 100 - m.nGasInt
		            m.cprodyr = STR(YEAR(m.dProdDate), 4)
		            IF ALLTRIM(m.cprodyr) = '0'
		                m.cprodyr = ''
		            ENDIF
		            m.crevbbl = crevbbl
		            m.crevmcf = crevmcf
		            IF m.noilbbl + m.ngasmcf > 0
		                IF llDays
		                    m.ndayson = lnDays
		                ELSE
		                    IF m.ndayson = 0
		                        m.ndayson = lnDays
		                    ENDIF
		                ENDIF
		            ELSE
		                m.ndayson = 0
		            ENDIF
		            m.nmonths = m.ndayson / 30
		            SELECT revsrc
		            SET ORDER TO crevkey
		            IF SEEK(m.crevbbl)
		                m.cbblpurch = crevname
		            ELSE
		                m.cbblpurch = ' '
		            ENDIF
		            IF SEEK(m.crevmcf)
		                m.cmcfpurch = crevname
		            ELSE
		                m.cmcfpurch = ' '
		            ENDIF
		*         IF m.nwellcount > 1
		            m.noilinc = m.noilinc / m.nwellcount
		            m.ngasinc = m.ngasinc / m.nwellcount
		            m.nothinc = m.nothinc / m.nwellcount
		            m.noilexpense = m.noilexpense / m.nwellcount
		            m.ngasexpense = m.ngasexpense / m.nwellcount
		            m.nothexpense = m.nothexpense / m.nwellcount
		
		            STORE 0 TO m.nworkoil, m.nworkgas, m.nworkngl
		            STORE 0 TO m.nroyoil, m.nroygas, m.nroyngl
		
		
		            SELECT disbhist  &&  Calculate the working interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		                IF lnReportOn = 1
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = disbhist.nRunNo_In AND crunyear = disbhist.cRunYear_in AND ctypeclose = disbhist.crectype
		                        IF FOUND()
		                            IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF disbhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ELSE
		                            LOOP
		                        ENDIF
		                    ELSE
		                        SELECT sysctl
		                        LOCATE FOR nrunno = disbhist.nrunno AND crunyear = disbhist.crunyear AND ctypeclose = disbhist.crectype
		                        IF FOUND()
		                            IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF disbhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		*  Production Year
		                IF lnReportOn = 2
		*  By production year doesn't care about suspense dates.  If it matches, it gets included
		                    IF disbhist.hyear <> m.cyear
		                        LOOP
		                    ENDIF
		                ENDIF
		
		*  Accounting Date Range
		                IF lnReportOn = 3
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = disbhist.nRunNo_In AND crunyear = disbhist.cRunYear_in AND ctypeclose = disbhist.crectype
		                        IF FOUND()
		                            IF NOT BETWEEN(sysctl.dacctdate, ldDate1, ldDate2)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF disbhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		                SELECT disbhist
		                m.nworkoil = m.nworkoil + disbhist.nOilRev
		                m.nworkgas = m.nworkgas + disbhist.nGasRev - ((disbhist.nCompress + disbhist.nGather) * lnMultiplier)
		                m.nworkngl = m.nworkngl + disbhist.nothrev
		            ENDSCAN
		
		            SELECT suspense  &&  Calculate the working interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		                IF lnReportOn = 1
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                        IF FOUND()
		                            IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ELSE
		                            LOOP
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		*  Production Year
		                IF lnReportOn = 2
		*  By production year doesn't care about suspense dates.  If it matches, it gets included
		                    IF suspense.hyear <> m.cyear
		                        LOOP
		                    ENDIF
		                ENDIF
		
		*  Accounting Date Range
		                IF lnReportOn = 3
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                        IF FOUND()
		                            IF NOT BETWEEN(sysctl.dacctdate, ldDate1, ldDate2)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		                SELECT suspense
		                m.nworkoil = m.nworkoil + suspense.nOilRev
		                m.nworkgas = m.nworkgas + suspense.nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		                m.nworkngl = m.nworkngl + suspense.nothrev
		            ENDSCAN
		
		            SELECT disbhist  &&  Calculate the Royalty interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv # 'W'
		                IF lnReportOn = 1
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = disbhist.nRunNo_In AND crunyear = disbhist.cRunYear_in AND ctypeclose = disbhist.crectype
		                        IF FOUND()
		                            IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF disbhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ELSE
		                            LOOP
		                        ENDIF
		                    ELSE
		                        SELECT sysctl
		                        LOCATE FOR nrunno = disbhist.nrunno AND crunyear = disbhist.crunyear AND ctypeclose = disbhist.crectype
		                        IF FOUND()
		                            IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF disbhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		*  Production Year
		                IF lnReportOn = 2
		*  By production year doesn't care about suspense dates.  If it matches, it gets included
		                    IF disbhist.hyear <> m.cyear
		                        LOOP
		                    ENDIF
		                ENDIF
		
		*  Accounting Date Range
		                IF lnReportOn = 3
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = disbhist.nRunNo_In AND crunyear = disbhist.cRunYear_in AND ctypeclose = disbhist.crectype
		                        IF FOUND()
		                            IF NOT BETWEEN(sysctl.dacctdate, ldDate1, ldDate2)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF disbhist.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		                SELECT disbhist
		                m.nroyoil = m.nroyoil + disbhist.nOilRev
		                m.nroygas = m.nroygas + disbhist.nGasRev - ((disbhist.nCompress + disbhist.nGather) * lnMultiplier)
		                m.nroyngl = m.nroyngl + disbhist.nothrev
		            ENDSCAN
		
		
		            SELECT suspense  &&  Calculate the Royalty interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv # 'W'
		                IF lnReportOn = 1
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                        IF FOUND()
		                            IF YEAR(dacctdate) <> VAL(m.cyear)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ELSE
		                            LOOP
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		*  Production Year
		                IF lnReportOn = 2
		*  By production year doesn't care about suspense dates.  If it matches, it gets included
		                    IF suspense.hyear <> m.cyear
		                        LOOP
		                    ENDIF
		                ENDIF
		
		*  Accounting Date Range
		                IF lnReportOn = 3
		*  Item has been in suspense, so check to see when it was originally earned using the _in values
		                    IF NOT EMPTY(cRunYear_in)
		                        SELECT sysctl
		                        LOCATE FOR nrunno = suspense.nRunNo_In AND crunyear = suspense.cRunYear_in AND ctypeclose = suspense.crectype
		                        IF FOUND()
		                            IF NOT BETWEEN(sysctl.dacctdate, ldDate1, ldDate2)
		*  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                                LOOP
		                            ENDIF
		                            IF suspense.lManual AND EMPTY(sysctl.cVersion)
		*  This is a converted suspense entry, so we don't care about it
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		                SELECT suspense
		                m.nroyoil = m.nroyoil + suspense.nOilRev
		                m.nroygas = m.nroygas + suspense.nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		                m.nroyngl = m.nroyngl + suspense.nothrev
		            ENDSCAN
		
		            m.noilinc    = m.noilinc + m.nflatoil
		            m.ngasinc    = m.ngasinc + m.nflatgas
		            m.cfacility  = ''
		            m.cfacpermit = ''
		            m.nsaltbbl   = m.nsaltbbl / m.nwellcount
		            m.nworkgas   = m.nworkgas / m.nwellcount
		            m.nworkoil   = m.nworkoil / m.nwellcount
		            m.nworkngl   = m.nworkngl / m.nwellcount
		            m.nroygas   = m.nroygas / m.nwellcount
		            m.nroyoil   = m.nroyoil / m.nwellcount
		            m.nroyngl   = m.nroyngl / m.nwellcount
		
		            SELECT wells
		            SET ORDER TO cwellid
		            SEEK(m.cwellid)
		            FOR lnX = 1 TO m.nwellcount
		                DO CASE
		                CASE lnX = 1
		                    m.cpermit  = m.cpermit1
		                    m.cpermit1 = ' '
		                    m.cnra = wells.cnra1
		                CASE lnX = 2
		                    m.cpermit  = m.cpermit2
		                    m.cpermit2 = ' '
		                    m.cnra = wells.cnra2
		                CASE lnX = 3
		                    m.cpermit  = m.cpermit3
		                    m.cpermit3 = ' '
		                    m.cnra = wells.cnra3
		                CASE lnX = 4
		                    m.cpermit  = m.cpermit4
		                    m.cpermit4 = ' '
		                    m.cnra = wells.cnra4
		                CASE lnX = 5
		                    m.cpermit  = m.cpermit5
		                    m.cpermit5 = ' '
		                    m.cnra = wells.cnra5
		                CASE lnX = 6
		                    m.cpermit  = m.cpermit6
		                    m.cpermit6 = ' '
		                    m.cnra = wells.cnra6
		                ENDCASE
		                m.cwellstate = lcState
		                m.crptgroup  = 'A'
		                m.nworkoil   = ROUND(m.nworkoil, 0)
		                m.nworkgas   = ROUND(m.nworkgas, 0)
		                m.nworkngl   = ROUND(m.nworkngl, 0)
		                m.nroyoil   = ROUND(m.nroyoil, 0)
		                m.nroygas   = ROUND(m.nroygas, 0)
		                m.nroyngl   = ROUND(m.nroyngl, 0)
		                m.noilinc    = ROUND(m.noilinc, 0)
		                m.ngasinc    = ROUND(m.ngasinc, 0)
		                m.nothinc    = ROUND(m.nothinc, 0)
		
		                m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		                SELECT annprod1
		                SET ORDER TO cidannp
		                SET DELETED OFF
		                DO WHILE SEEK(m.cidannp)
		                    m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		                ENDDO
		                SET DELETED ON
		                m.cstate = lcCompState
		                INSERT INTO temp FROM MEMVAR
		            ENDFOR
		        ENDSCAN
		    ENDIF
		
		    llPACodes = .F.
		
		    SELECT * FROM temp INTO CURSOR annprodtemp
		
		    swselect('wells')
		    SET ORDER TO cwellid
		
		    SELECT temp
		    SCAN
		        SCATTER MEMVAR
		        lnTotOil = noilbbl
		        lnTotGas = ngasmcf
		
		* Lookup county number from API
		        SELECT wells
		        IF SEEK(m.cwellid)        
		                SCATTER MEMVAR
		                DO CASE
		                CASE UPPER(m.ccounty) = 'BARBOUR'
		                    m.cwvdistrict = '01'
		                CASE UPPER(m.ccounty) = 'BERKELEY'
		                    m.cwvdistrict = '02'
		                CASE UPPER(m.ccounty) = 'BOONE'
		                    m.cwvdistrict = '03'
		                CASE UPPER(m.ccounty) = 'BRAXTON'
		                    m.cwvdistrict = '04'
		                CASE UPPER(m.ccounty) = 'BROOKE'
		                    m.cwvdistrict = '05'
		                CASE UPPER(m.ccounty) = 'CABELL'
		                    m.cwvdistrict = '06'
		                CASE UPPER(m.ccounty) = 'CALHOUN'
		                    m.cwvdistrict = '07'
		                CASE UPPER(m.ccounty) = 'CLAY'
		                    m.cwvdistrict = '08'
		                CASE UPPER(m.ccounty) = 'DODDRIDGE'
		                    m.cwvdistrict = '09'
		                CASE UPPER(m.ccounty) = 'FAYETTE'
		                    m.cwvdistrict = '10'
		                CASE UPPER(m.ccounty) = 'GILMER'
		                    m.cwvdistrict = '11'
		                CASE UPPER(m.ccounty) = 'GRANT'
		                    m.cwvdistrict = '12'
		                CASE UPPER(m.ccounty) = 'GREENBRIER'
		                    m.cwvdistrict = '13'
		                CASE UPPER(m.ccounty) = 'HAMPSHIRE'
		                    m.cwvdistrict = '14'
		                CASE UPPER(m.ccounty) = 'HANCOCK'
		                    m.cwvdistrict = '15'
		                CASE UPPER(m.ccounty) = 'HARDY'
		                    m.cwvdistrict = '16'
		                CASE UPPER(m.ccounty) = 'HARRISON'
		                    m.cwvdistrict = '17'
		                CASE UPPER(m.ccounty) = 'JACKSON'
		                    m.cwvdistrict = '18'
		                CASE UPPER(m.ccounty) = 'JEFFERSON'
		                    m.cwvdistrict = '19'
		                CASE UPPER(m.ccounty) = 'KANAWHA'
		                    m.cwvdistrict = '20'
		                CASE UPPER(m.ccounty) = 'LEWIS'
		                    m.cwvdistrict = '21'
		                CASE UPPER(m.ccounty) = 'LINCOLN'
		                    m.cwvdistrict = '22'
		                CASE UPPER(m.ccounty) = 'LOGAN'
		                    m.cwvdistrict = '23'
		                CASE UPPER(m.ccounty) = 'MARION'
		                    m.cwvdistrict = '24'
		                CASE UPPER(m.ccounty) = 'MARSHALL'
		                    m.cwvdistrict = '25'
		                CASE UPPER(m.ccounty) = 'MASON'
		                    m.cwvdistrict = '26'
		                CASE UPPER(m.ccounty) = 'MCDOWELL'
		                    m.cwvdistrict = '27'
		                CASE UPPER(m.ccounty) = 'MERCER'
		                    m.cwvdistrict = '28'
		                CASE UPPER(m.ccounty) = 'MINERAL'
		                    m.cwvdistrict = '29'
		                CASE UPPER(m.ccounty) = 'MINGO'
		                    m.cwvdistrict = '30'
		                CASE UPPER(m.ccounty) = 'MONONGALIA'
		                    m.cwvdistrict = '31'
		                CASE UPPER(m.ccounty) = 'MONROE'
		                    m.cwvdistrict = '32'
		                CASE UPPER(m.ccounty) = 'MORGAN'
		                    m.cwvdistrict = '33'
		                CASE UPPER(m.ccounty) = 'NICHOLAS'
		                    m.cwvdistrict = '34'
		                CASE UPPER(m.ccounty) = 'OHIO'
		                    m.cwvdistrict = '35'
		                CASE UPPER(m.ccounty) = 'PENDELTON'
		                    m.cwvdistrict = '36'
		                CASE UPPER(m.ccounty) = 'PLEASANTS'
		                    m.cwvdistrict = '37'
		                CASE UPPER(m.ccounty) = 'POCAHONTAS'
		                    m.cwvdistrict = '38'
		                CASE UPPER(m.ccounty) = 'PRESTON'
		                    m.cwvdistrict = '39'
		                CASE UPPER(m.ccounty) = 'PUTNAM'
		                    m.cwvdistrict = '40'
		                CASE UPPER(m.ccounty) = 'RALEIGH'
		                    m.cwvdistrict = '41'
		                CASE UPPER(m.ccounty) = 'RANDOLPH'
		                    m.cwvdistrict = '42'
		                CASE UPPER(m.ccounty) = 'RITCHIE'
		                    m.cwvdistrict = '43'
		                CASE UPPER(m.ccounty) = 'ROANE'
		                    m.cwvdistrict = '44'
		                CASE UPPER(m.ccounty) = 'SUMMERS'
		                    m.cwvdistrict = '45'
		                CASE UPPER(m.ccounty) = 'TAYLOR'
		                    m.cwvdistrict = '46'
		                CASE UPPER(m.ccounty) = 'TUCKER'
		                    m.cwvdistrict = '47'
		                CASE UPPER(m.ccounty) = 'TYLER'
		                    m.cwvdistrict = '48'
		                CASE UPPER(m.ccounty) = 'UPSHUR'
		                    m.cwvdistrict = '49'
		                CASE UPPER(m.ccounty) = 'WAYNE'
		                    m.cwvdistrict = '50'
		                CASE UPPER(m.ccounty) = 'WEBSTER'
		                    m.cwvdistrict = '51'
		                CASE UPPER(m.ccounty) = 'WETZEL'
		                    m.cwvdistrict = '52'
		                CASE UPPER(m.ccounty) = 'WIRT'
		                    m.cwvdistrict = '53'
		                CASE UPPER(m.ccounty) = 'WOOD'
		                    m.cwvdistrict = '54'
		                CASE UPPER(m.ccounty) = 'WYOMING'
		                    m.cwvdistrict = '55'
		                OTHERWISE
		                    m.cwvdistrict = '00'
		                ENDCASE
		           ENDIF  
		*!*	            m.capi = cpermit1
		*!*	            lcCounty = STRTRAN(m.capi,'-','')
		*!*	            lcCounty = STRTRAN(lcCounty,' ','')
		*!*	            m.cwvdistrict = SUBSTR(ALLTRIM(lcCounty),3,3)
		
		            IF NOT llNoProd
		                IF m.noilbbl > 0 OR m.ngasmcf > 0 OR m.nsaltbbl > 0 OR m.noilinc > 0 OR m.ngasinc > 0 OR m.nothinc > 0
		                    m.cstate = lcCompState
		                    INSERT INTO annprod FROM MEMVAR
		                    lnRecords = lnRecords + 1
		                ENDIF
		            ELSE
		                m.cstate = lcCompState
		                INSERT INTO annprod FROM MEMVAR
		                lnRecords = lnRecords + 1
		            ENDIF
		        ENDSCAN
		
		        oProgress.CloseProgress()
		
		* Build the owner file if we're doing the WV annual return
		        IF THISFORM.cstate = 'WV'
		            THISFORM.Build_WV_Owners()
		        ENDIF
		*
		*  See how many records were created
		*
		        lnCount = 0
		        SELECT annprod
		        COUNT FOR cyear = m.cyear AND cwellstate = lcState TO lnCount
		        SET ORDER TO cwellid
		
		        WAIT WINDOW NOWAIT 'Finishing up calculations...'
		        SELECT annprod
		        TABLEUPDATE(.T.)
		        SELECT form6s
		        TABLEUPDATE(.T., .T.)
		
		* Zero out the days on unless the well was started during the year.
		        swselect('annprod')
		        UPDATE annprod SET ndayson = 0 WHERE cyear = m.cyear AND YEAR(dProdDate) # VAL(m.cyear) AND cwellstate = lcState
		
		        WAIT CLEAR
		
		        IF lnRecords = 0
		            THISFORM.oMessage.DISPLAY('There were no records found for the given range for this state.')
		            llReturn = .F.
		            EXIT
		        ELSE
		            THISFORM.oMessage.DISPLAY('Created ' + ALLTRIM(STR(lnRecords)) + ' Schedule 2 Records')
		        ENDIF
		
		        SET DECIMALS TO lnDecimal
		
		        swclose('wellann1')
		        swclose('wellann2')
		        swclose('temp')
		
		    CATCH TO loError
		        llReturn = .F.
		        DO errorlog WITH 'BuildFile', loError.LINENO, 'WV Annual Return Create', loError.ERRORNO, loError.MESSAGE, '', loError
		        MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		            'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		    ENDTRY
		
		    RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE buildpadata		&& Gets the PA waste and disposal data for a Particular PA well
	ENDPROC

	PROCEDURE build_ny		&& Builds the NY Annual return file
	ENDPROC

	PROCEDURE build_oh		&& Builds the Ohio Form 10 file
	ENDPROC

	PROCEDURE build_pa		&& Builds the PA waste water return
	ENDPROC

	PROCEDURE build_wv		&& Builds WV Annual Return File
		LOCAL lnReportOn, ldDate1, ldDate2, llActive, lnCount, lnRecords, lcState, llCompress, lnMultiplier
		LOCAL llLeapYr, cTaxYear, cOwnerNo, llUseProducer_for_Working, lcWorkint, llOverride, lnTally, oProgress
		LOCAL  llNoProd, llPACodes, lnBBLs, lnGasInt, lnMax, lnOilInt, lnTotGas, lnTotOil, lnX, lnpct
		LOCAL lcWhereW, llReturn, loError, m.cyear
		
		llReturn = .T.
		
		TRY
		   STORE .F. TO llUseProducer_for_Working, llOverride
		   STORE ' ' TO lcWorkint
		   lnCount      = 0
		   lnRecords    = 0
		   lcState      = THISFORM.cstate
		   m.cwellstate = lcState
		   m.cYear      = ALLTRIM(THISFORM.txtcYear.VALUE)
		   m.cTaxYear   = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		   llActive     = .F.
		   ldDate1      = DATE()
		   ldDate2      = DATE()
		   lnReportOn   = thisform.opgyear.value
		   llNoProd     = .T.
		   llCompress   = .F.
		   lnMultiplier = IIF(llCompress, 1, 0)
		      
		   swselect('stateaccounts')
		   LOCATE FOR cstate = 'WV'
		   IF FOUND()
		      lcAccount = caccount
		   ELSE
		      lcAccount = ''
		   ENDIF 
		
		   * Check on the existence of the application object
		   * if it doesn't exist, we're running in development
		   * mode and need to initialize the company address info.
		   IF TYPE('m.goApp') = 'O'
		      swselect('compmast')
		      LOCATE FOR cidcomp = m.goapp.cidcomp
		      IF FOUND()
		         lcCompState = cstate
		      ELSE
		         lcCompState = m.goapp.cstate
		      ENDIF
		      m.cproducer  = m.goapp.ccompanyname
		      m.cagent     = m.goapp.cAgentname
		      m.caddress   = m.goapp.cAddress1
		      m.ctaxid     = m.goapp.ctaxid
		      m.ccity      = m.goapp.ccity
		      m.cstate     = m.goapp.cstate
		      m.czip       = m.goapp.czip
		      m.ccontact   = m.goapp.ccontact
		      m.ctelephone = m.goapp.cPhoneNo
		   ELSE
		      m.cproducer  = 'SherWare, Inc.'
		      m.cagent     = 'SherWare, Inc.'
		      m.caddress   = 'PO Box 223'
		      m.ctaxid     = '99-9999999'
		      m.ccontact   = 'Phil Sherwood'
		      m.ctelephone = '3302623115'
		      m.ccity      = 'Wooster'
		      m.cstate     = 'OH'
		      m.czip       = '44691'
		   ENDIF
		
		   SELECT annprod
		   COUNT FOR cYear = m.cYear AND cwellstate = lcState TO lnCount
		   IF lnCount > 0
		      IF NOT THISFORM.oMessage.CONFIRM('Production data already exists for ' + m.cYear + ' Do you want to overwrite it?')
		         WAIT WIND NOWAIT 'File Create Cancelled.'
		         llReturn = .F.
		         EXIT
		      ELSE
		         DELETE FOR cYear = m.cYear AND cwellstate = lcState
		         SELECT form6s
		         DELETE FOR cYear = m.cYear AND cstate = lcState
		      ENDIF
		   ENDIF
		
		   * Determine if the year is a leap year
		   llLeapYr = swLeapYear(m.cYear)
		
		
		   DO CASE
		      CASE lnReportOn = 1  &&  Accounting Year
		         lcWhereW  = "crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		      CASE lnReportOn = 2  &&  Production Year
		         lcWhereW = "wellhist.hyear  = m.cYear"
		      CASE lnReportOn = 3  &&  Accounting Date Range
		         lcWhereW = "crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE BETWEEN(dacctdate,ldDate1,ldDate2) and ctypeclose='R')"
		   ENDCASE
		
		   SET DELETED ON
		
		   SELECT  wellhist.cwellid, ;
		      wells.cwellname, ;
		      m.cYear AS cYear, ;
		      wells.cpermit1, ;
		      wells.cpermit2, ;
		      wells.cpermit3, ;
		      wells.cpermit4, ;
		      wells.cpermit5, ;
		      wells.cpermit6, ;
		      wells.ccounty, ;
		      wells.ctownship, ;
		      wells.cwvdistrict, ;
		      wells.cparcel, ;
		      wells.csection, ;
		      wells.clot AS clot, ;
		      wells.lhousegas, ;
		      wells.lnglethane, ;
		      wells.lnglpropane, ;
		      wells.lnglbutane, ;
		      wells.lnglisobutane, ;
		      wells.lnglpentane, ;
		      SPACE(25) AS cmeterserialno, ;
		      SPACE(25) AS cmeterloc, ;
		      SPACE(40) as cmetercity, ;
		      SPACE(10) as cmeterzip, ;
		      SPACE(2)  as cmeterstate, ;
		      IIF(EMPTY(wells.cnra1), '@' + wells.cwellid + SPACE(10), wells.cnra1) AS cnra, ;
		      wells.nOilInt, ;
		      wells.nGasInt, ;
		      wells.dProdDate, ;
		      PADR(MLINE(wells.mwellnote, 1), 20, ' ') AS NOTE, ;
		      lcAccount AS cOwnerNo, ;
		      wells.nacres,  ;
		      wells.nacres as nleaseacres, ;
		      wells.cfieldid AS cfield, ;
		      wells.cformation, ;
		      0 AS nmonths, ;
		      wells.crevbbl, ;
		      wells.crevmcf, ;
		      wells.cwellstat AS cwellstatus, ;
		      wells.nwellcount, ;
		      wells.cstate AS cwellstate, ;
		      SUM(wellhist.nwrkint) AS nworkint, ;
		      SUM(wellhist.ndayson) AS ndayson, ;
		      SUM(wellhist.ntotbbl) AS noilbbl, ;
		      SUM(wellhist.ntotmcf) AS ngasmcf, ;
		      SUM(wellhist.ntotprod) AS nothbbl, ;
		      SUM(wellhist.ntotsalt) AS nsaltbbl, ;
		      SUM(wellhist.ngrossgas+wellhist.nflatgas - ((wellhist.nCompress + wellhist.nGather) * lnMultiplier)) AS ngasinc, ;  &&  lnMultiplier is either going to be 0 or 1, depending whether comp/gathering is excluded
		      SUM(wellhist.ngrossoil) AS noilinc, ;
		      SUM(wellhist.nothinc) AS nothinc, ;
		      SUM(wellhist.nflatgas) AS nflatgas, ;
		      SUM(wellhist.nflatoil) AS nflatoil, ;
		      SUM(wellhist.ntotale) as nexpense0, ;
		      SUM(wellhist.nexpcl1) as nexpense1, ;
		      SUM(wellhist.nexpcl2) as nexpense2, ;
		      SUM(wellhist.nexpcl3) as nexpense3, ;
		      SUM(wellhist.nexpcl4) as nexpense4, ;
		      SUM(wellhist.nexpcl5) AS nexpense5, ;
		      000000000.00 as noilexpense, ;
		      000000000.00 as ngasexpense, ;
		      000000000.00 as nothexpense, ;
		      000000000.00 AS nworkoil, ;
		      000000000.00 AS nworkgas, ;
		      000000000.00 AS nworkngl, ;
		      wells.cmeterid ;
		      FROM wellhist, wells ;
		      WHERE wellhist.cwellid = wells.cwellid ;
		      AND &lcWhereW ;
		      AND wells.cstate     = lcState ;
		      AND wells.lthird_prty <> .T. ;
		      AND IIF(wells.cwellstat='P',YEAR(wells.dplugged)=VAL(m.cYear),wells.cwellstat # 'S' AND wells.cwellstat # 'P') ; && Don't include sold or plugged wells
		   INTO CURSOR wellann1 READWRITE  ;
		      ORDER BY wells.cnra1, wells.cwellid ;
		      GROUP BY wells.cnra1, wells.cwellid
		
		   SELECT  wells.cwellid, ;
		      wells.cwellname, ;
		      m.cYear AS cYear, ;
		      wells.cpermit1, ;
		      wells.cpermit2, ;
		      wells.cpermit3, ;
		      wells.cpermit4, ;
		      wells.cpermit5, ;
		      wells.cpermit6, ;
		      wells.ccounty, ;
		      wells.ctownship, ;
		      wells.cwvdistrict, ;
		      wells.cparcel, ;
		      wells.csection, ;
		      wells.clot AS clot, ;
		      wells.lhousegas, ;
		      wells.lnglethane, ;
		      wells.lnglpropane, ;
		      wells.lnglbutane, ;
		      wells.lnglisobutane, ;
		      wells.lnglpentane, ;
		      IIF(EMPTY(wells.cnra1), '@' + wells.cwellid + SPACE(10), wells.cnra1) AS cnra, ;  &&  Pick up the well ID with @ before it if blank, to make it unique - report will filter this out with a print when - BH 07/28/2008
		      wells.nOilInt, ;
		      wells.nGasInt, ;
		      wells.dProdDate, ;
		      PADR(MLINE(wells.mwellnote, 1), 20, ' ') AS NOTE, ;
		      lcAccount AS cOwnerNo, ;
		      wells.nacres,  ;
		      wells.nacres as nleaseacres, ;
		      wells.cfieldid AS cfield, ;
		      wells.cformation, ;
		      0 AS nmonths, ;
		      000000000.00 AS noilinc, ;
		      000000000.00 AS ngasinc, ;
		      000000000.00 AS nothinc, ;
		      000000000.00 AS nworkoil, ;
		      000000000.00 AS nworkgas, ;
		      000000000.00 AS nworkngl, ;
		      000000000.00 AS nflatgas, ;
		      000000000.00 AS nflatoil, ;
		      000000000.00 AS nexpense0, ;
		      000000000.00 AS nexpense1, ;
		      000000000.00 AS nexpense2, ;
		      000000000.00 AS nexpense3, ;
		      000000000.00 AS nexpense4, ;
		      000000000.00 AS nexpense5, ;
		      000000000.00 as noilexpense, ;
		      000000000.00 as ngasexpense, ;
		      000000000.00 as nothexpense, ;
		      wells.crevbbl, ;
		      wells.crevmcf, ;
		      wells.cwellstat AS cwellstatus, ;
		      wells.nwellcount, ;
		      wells.cstate AS cwellstate, ;
		      0 AS ndayson, ;
		      0 AS noilbbl, ;
		      0 AS ngasmcf, ;
		      0 AS nothbbl, ;
		      0 AS nsaltbbl, ;
		      SPACE(25) AS cmeterserialno, ;
		      SPACE(25) AS cmeterloc, ;
		      SPACE(40) as cmetercity, ;
		      SPACE(10) as cmeterzip, ;
		      SPACE(2)  as cmeterstate, ;
		      wells.cmeterid ;
		      FROM wells ;
		      WHERE wells.cstate   = lcState ;
		      AND wells.cwellid NOT IN (SELECT  cwellid ;
		      FROM wellhist ;
		      WHERE &lcWhereW) ;
		      AND wells.lthird_prty <> .T. ;
		      AND IIF(wells.cwellstat='P',YEAR(wells.dplugged)=VAL(m.cYear),wells.cwellstat # 'S' AND wells.cwellstat # 'P') ; && Don't include sold or plugged wells
		   INTO CURSOR wellann2 READWRITE ;
		      ORDER BY wells.cnra1, wells.cwellid ;
		      GROUP BY wells.cnra1, wells.cwellid
		
		   SELECT wellann1
		   SCAN
		      swselect('meters')
		      LOCATE FOR cmeterid = wellann1.cmeterid
		      IF FOUND()
		         SELECT wellann1
		         REPLACE cmeterserialno WITH meters.cmeterserialno, ;
		            cmeterloc      WITH meters.cmeterloc, ;
		            cmetercity     WITH meters.cmetercity, ;
		            cmeterstate    WITH meters.cmeterstate, ;
		            cmeterzip      WITH meters.cmeterzip
		         IF EMPTY(meters.cmeterstate)
		            REPLACE cmeterstate WITH wellann1.cwellstate
		         ENDIF 
		      ENDIF
		      
		      * The district is the township so use it if the district is blank
		      IF EMPTY(wellann1.cwvdistrict)
		         SELECT wellann1
		         REPLACE cwvdistrict WITH ALLTRIM(ctownship)
		      ELSE
		         SELECT wellann1
		         REPLACE cwvdistrict WITH ALLTRIM(cwvdistrict)
		      ENDIF 
		
		      * Check for house gas well and change status
		      IF wellann1.lhousegas
		         SELECT wellann1
		         REPLACE cwellstatus WITH 'H'
		      ENDIF
		
		      SELECT wellann1
		      * Figure out ratio of expenses between oil and gas and other
		      IF THISFORM.chkexpenses.VALUE
		         STORE 0 TO lnOilExpense, lnGasExpense, lnOthExpense
		         REPLACE nOilExpense WITH lnOilExpense, ;
		                 nGasExpense WITH lnGasExpense, ;
		                 nOthExpense WITH lnOthExpense
		                   
		      ELSE
		         lnOilInc = wellann1.noilinc
		         lnGasInc = wellann1.ngasinc
		         lnOthInc = wellann1.nothinc
		         lnTotInc = lnOilInc + lnGasInc + lnOthInc
		         STORE 0 TO lnOilExpense, lnGasExpense, lnOthExpense
		         IF lnTotInc # 0
		            lnOilRatio = lnOilInc/lnTotInc
		            lnGasRatio = lnGasInc/lnTotInc
		            lnOthRatio = lnOthInc/lnTotInc
		            lnOilExpense = swNetExp(ROUND(wellann1.nexpense0 * lnOilRatio,2),wellann1.cwellid,.T.,'0','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense1 * lnOilRatio,2),wellann1.cwellid,.T.,'1','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense2 * lnOilRatio,2),wellann1.cwellid,.T.,'2','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense3 * lnOilRatio,2),wellann1.cwellid,.T.,'3','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense4 * lnOilRatio,2),wellann1.cwellid,.T.,'4','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense5 * lnOilRatio,2),wellann1.cwellid,.T.,'5','B')
		            lnGasExpense = swNetExp(ROUND(wellann1.nexpense0 * lnGasRatio,2),wellann1.cwellid,.T.,'0','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense1 * lnGasRatio,2),wellann1.cwellid,.T.,'1','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense2 * lnGasRatio,2),wellann1.cwellid,.T.,'2','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense3 * lnGasRatio,2),wellann1.cwellid,.T.,'3','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense4 * lnGasRatio,2),wellann1.cwellid,.T.,'4','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense5 * lnOthRatio,2),wellann1.cwellid,.T.,'5','B')               
		            lnOthExpense = swNetExp(ROUND(wellann1.nexpense0 * lnOthRatio,2),wellann1.cwellid,.T.,'0','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense1 * lnOthRatio,2),wellann1.cwellid,.T.,'1','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense2 * lnOthRatio,2),wellann1.cwellid,.T.,'2','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense3 * lnOthRatio,2),wellann1.cwellid,.T.,'3','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense4 * lnOthRatio,2),wellann1.cwellid,.T.,'4','B') + ;
		                           swNetExp(ROUND(wellann1.nexpense5 * lnOthRatio,2),wellann1.cwellid,.T.,'5','B')
		            SELECT wellann1
		            REPLACE noilexpense WITH lnOilExpense, ;
		               ngasexpense WITH lnGasExpense, ;
		               nothexpense WITH lnOthExpense
		         ENDIF
		      ENDIF
		   ENDSCAN
		   SELECT wellann2
		   SCAN
		      swselect('meters')
		      LOCATE FOR cmeterid = wellann2.cmeterid
		      IF FOUND()
		         SELECT wellann2
		         REPLACE cmeterserialno WITH meters.cmeterserialno, ;
		            cmeterloc      WITH meters.cmeterloc, ;
		            cmetercity     WITH meters.cmetercity, ;
		            cmeterstate    WITH meters.cmeterstate, ;
		            cmeterzip      WITH meters.cmeterzip
		         IF EMPTY(meters.cmeterstate)
		            REPLACE cmeterstate WITH wellann2.cwellstate
		         ENDIF 
		      ENDIF
		   
		      * Check for house gas well and change status
		      IF wellann2.lhousegas
		         SELECT wellann2
		         REPLACE cwellstatus WITH 'H'
		      ENDIF
		      
		      
		       * The district is the township so use it if the district is blank
		      IF EMPTY(wellann2.cwvdistrict)
		         SELECT wellann2
		          REPLACE cwvdistrict WITH ALLTRIM(ctownship) 
		      ELSE
		         SELECT wellann2
		         REPLACE cwvdistrict WITH ALLTRIM(cwvdistrict) 
		      ENDIF 
		
		   ENDSCAN
		
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Build_WV', loError.LINENO, 'WV Annual Return Create', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE build_wv_owners
		
		LPARAMETERS lnRecords
		LOCAL lcWhere, lcWhereS, ldDate1, ldDate2, llActive, llCompress, llNoProd, lnCount
		LOCAL lnMax, lnMultiplier, lnReportOn, llUseProducer_for_Working, llOverride, lcWorkInt
		LOCAL lcState, llContinue, llReturn, loError
		LOCAL cOwnerNo, cTaxYear, cYear, cidstown, cpermit, cstate, ctypeinv, cwellname, cwellstate
		LOCAL nGasInt, nOilInt, ndiff, ngasval, noilval, ntotalval, oProgress
		
		TRY
		   m.cYear      = ALLTRIM(THISFORM.txtcYear.VALUE)
		
		   lcState      = THISFORM.cstate
		   m.cwellstate = lcState
		
		   m.cTaxYear   = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		   llActive     = .F.
		   ldDate1      = DATE()
		   ldDate2      = DATE()
		   lnReportOn   = THISFORM.opgyear.VALUE
		   llNoProd     = .T.
		   llCompress   = .F.
		   lnMultiplier = IIF(llCompress, 1, 0)
		
		   llUseProducer_for_Working = THISFORM.chkUseProducer.VALUE
		   llOverride                = THISFORM.chkUseOverride.VALUE
		
		   IF llUseProducer_for_Working
		      lcWorkInt  = m.goapp.ccompanyname
		   ELSE
		      lcWorkInt  = 'Working Interest'
		   ENDIF
		
		* Check on the existence of the application object
		* if it doesn't exist, we're running in development
		* mode and need to initialize the company address info.
		   IF TYPE('m.goApp') = 'O'
		      swselect('compmast')
		      LOCATE FOR cidcomp = m.goapp.cidcomp
		      IF FOUND()
		         lcCompState = cstate
		      ELSE
		         lcCompState = m.goapp.cstate
		      ENDIF
		      m.cproducer  = m.goapp.ccompanyname
		      m.cagent     = m.goapp.cAgentname
		      m.caddress   = m.goapp.cAddress1
		      m.ctaxid     = m.goapp.ctaxid
		      m.ccity      = m.goapp.ccity
		      m.cstate     = m.goapp.cstate
		      m.czip       = m.goapp.czip
		      m.ccontact   = m.goapp.ccontact
		      m.ctelephone = m.goapp.cPhoneNo
		   ELSE
		      m.cproducer  = 'SherWare, Inc.'
		      m.cagent     = 'SherWare, Inc.'
		      m.caddress   = 'PO Box 223'
		      m.ctaxid     = '99-9999999'
		      m.ccontact   = 'Phil Sherwood'
		      m.ctelephone = '3302623115'
		      m.ccity      = 'Wooster'
		      m.cstate     = 'OH'
		      m.czip       = '44691'
		   ENDIF
		
		   DO CASE
		      CASE lnReportOn = 1
		         lcWhere1  = "EMPTY(csusptype) and crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		         lcWhere2 = "not EMPTY(csusptype) and crunyear_in+PADL(TRANSFORM(nrunno_in),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		         lcWhereS = "crunyear_in+PADL(TRANSFORM(nrunno_in),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		      CASE lnReportOn = 2
		         lcWhere1 = 'empty(csusptype) and disbhist.hyear = m.cYear'
		         lcWhere2 = "not EMPTY(csusptype) and disbhist.hyear = m.cYear"
		         lcWhereS = 'suspense.hyear = m.cYear'
		      CASE lnReportOn = 3
		         lcWhere1 = "EMPTY(csusptype) and crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE BETWEEN(dacctdate,ldDate1,ldDate2) and ctypeclose='R')"
		         lcWhere2 =  "not EMPTY(csusptype) and crunyear_in+PADL(TRANSFORM(nrunno_in),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE BETWEEN(dacctdate,ldDate1,ldDate2) and ctypeclose='R')"
		         lcWhereS = "suspense.cRunYear_in+PADL(TRANSFORM(suspense.nRunNo_In),3,'0') IN " + ;
		            "(SELECT cRunYear+PADL(TRANSFORM(nRunNo),3,'0') FROM sysctl WHERE BETWEEN(dAcctDate,ldDate1,ldDate2) AND cTypeclose = 'R')"
		   ENDCASE
		
		
		* Make a cursor copy of Form6s for this year's records
		   llContinue =  make_copy('Form6s', 'Temp6s')
		
		   IF NOT llContinue
		      MESSAGEBOX('Unable to create the temp owner file.', 16, 'File Creation Error')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   SELECT temp6s
		   INDEX ON cownerid + cwellid TAG ownwell
		
		
		*
		*  Build Temp6s file  (This is only for WV wells.)
		*
		
		   SELE cnra, cwellid, cYear, SUM(noilinc) AS noilinc, SUM(ngasinc) AS ngasinc, SUM(nothinc) AS nothinc, cpermit ;
		      FROM annprod WITH (BUFFERING = .T.) ;
		      WHERE annprod.cYear = m.cYear ;
		      AND cwellstate = lcState ;
		      INTO CURSOR tempann1 READWRITE ;
		      ORDER BY cnra, cwellid, cYear ;
		      GROUP BY cnra, cwellid, cYear
		   SELE cnra, cwellid, cYear, SUM(noilinc) AS noilinc, SUM(ngasinc) AS ngasinc, SUM(nothinc) AS nothinc, cpermit ;
		      FROM annprod WITH (BUFFERING = .T.) ;
		      WHERE annprod.cYear = m.cYear ;
		      AND cwellstate = lcState ;
		      INTO CURSOR tempann READWRITE ;
		      ORDER BY cnra, cwellid, cYear ;
		      GROUP BY cnra, cwellid, cYear
		   lnMax = _TALLY
		
		   swselect('wells')
		   SET ORDER TO cwellid
		
		   lcYear = m.cYear
		   swselect('form6s')
		   SCATTER MEMVAR BLANK
		   m.cTaxYear = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		   m.cYear    = lcYear
		   lnCount    = 0
		   oProgress  = THISFORM.oMessage.ProgressBarEx('Building Owner Records for WV Annual Return....')
		   oProgress.SetProgressRange(0, lnMax)
		
		
		* Build Royalty Owners
		* Get non-suspense entries  (csusptype is blank)
		   WAIT WINDOW NOWAIT 'Building Royalty Interest Owners Totals'
		   SELECT  disbhist.cwellid, ;
		           disbhist.cownerid, ;
		           investor.cownname AS cRoyName, ;
		           investor.caddress1a AS cRoyAddr1, ;
		           investor.caddress1b AS cRoyAddr2, ;
		           investor.ccity1 AS cwvcity, ;
		           investor.caddress1a AS cWVAddress, ;
		           investor.cstate1 AS cwvstate, ;
		           investor.czip1 AS cwvzipcode, ;
		           IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		           investor.ctaxid AS cwvtaxid, ;
		           CAST(MAX(ownpcts.nrevoil) AS N(13, 8)) AS nOilInt, ;
		           CAST(MAX(ownpcts.nrevgas) AS N(13, 8)) AS nGasInt, ;
		           CAST(MAX(ownpcts.nrevoth) AS N(13, 8)) AS nOthInt, ;
		           TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		           SUM(disbhist.nOilRev) AS noilval, ;
		           SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval, ;
		           SUM(disbhist.nothrev) AS nothval, ;
		           wells.cnra1 AS cnra, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           m.cTaxYear AS cTaxYear, ;
		           disbhist.ctypeinv ;
		       FROM disbhist ;
		       JOIN ownpcts ;
		           ON disbhist.ciddisb = ownpcts.ciddisb ;
		       JOIN wells ;
		           ON disbhist.cwellid = wells.cwellid ;
		       JOIN investor ;
		           ON disbhist.cownerid = investor.cownerid ;
		       WHERE INLIST(disbhist.ctypeinv, 'L', 'O') ;
		           AND disbhist.lFlat = .F. ;
		           AND wells.cstate = lcState ;
		           AND &lcWhere1 ;
		           AND (disbhist.lManual = .F. ;
		             OR (disbhist.lManual = .T. ;
		               AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                    FROM sysctl ;
		                    WHERE EMPTY(cVersion) ;
		                        AND cTypeclose = 'R'))) ;
		       INTO CURSOR tmpinv READWRITE ;
		       ORDER BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           disbhist.ctypeinv ;
		       GROUP BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           disbhist.ctypeinv
		
		   INDEX ON cownerid + cnra + cwellid + ctypeinv TAG owntype
		
		* Suspense entries (csusptype not blank)
		   SELECT  disbhist.cwellid, ;
		           disbhist.cownerid, ;
		           investor.cownname AS cRoyName, ;
		           investor.caddress1a AS cRoyAddr1, ;
		           investor.caddress1b AS cRoyAddr2, ;
		           investor.caddress1a AS cWVAddress, ;
		           investor.ccity1 AS cwvcity, ;
		           investor.cstate1 AS cwvstate, ;
		           investor.czip1 AS cwvzipcode, ;
		           IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		           investor.ctaxid AS cwvtaxid, ;
		           CAST(MAX(ownpcts.nrevoil) AS N(13, 8)) AS nOilInt, ;
		           CAST(MAX(ownpcts.nrevgas) AS N(13, 8)) AS nGasInt, ;
		           CAST(MAX(ownpcts.nrevoth) AS N(13, 8)) AS nOthInt, ;
		           TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		           SUM(disbhist.nOilRev) AS noilval, ;
		           SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval, ;
		           SUM(disbhist.nothrev) AS nothval, ;
		           wells.cnra1 AS cnra, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           m.cTaxYear AS cTaxYear, ;
		           disbhist.ctypeinv ;
		       FROM disbhist ;
		       JOIN ownpcts ;
		           ON disbhist.ciddisb = ownpcts.ciddisb ;
		       JOIN wells ;
		           ON disbhist.cwellid = wells.cwellid ;
		       JOIN investor ;
		           ON disbhist.cownerid = investor.cownerid ;
		       WHERE investor.cownerid == disbhist.cownerid ;
		           AND INLIST(disbhist.ctypeinv, 'L', 'O') ;
		           AND disbhist.lFlat = .F. ;
		           AND wells.cstate = lcState ;
		           AND &lcWhere2 ;
		           AND (disbhist.lManual = .F. ;
		             OR (disbhist.lManual = .T. ;
		               AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                    FROM sysctl ;
		                    WHERE EMPTY(cVersion) ;
		                        AND cTypeclose = 'R'))) ;
		       INTO CURSOR tmpinv1 ;
		       ORDER BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           disbhist.ctypeinv ;
		       GROUP BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           disbhist.ctypeinv
		
		* Get entries still in suspense processed during the year
		   SELECT  suspense.cwellid, ;
		           suspense.cownerid, ;
		           investor.cownname AS cRoyName, ;
		           investor.caddress1a AS cRoyAddr1, ;
		           investor.caddress1b AS cRoyAddr2, ;
		           investor.caddress1a AS cWVAddress, ;
		           investor.ccity1 AS cwvcity, ;
		           investor.cstate1 AS cwvstate, ;
		           investor.czip1 AS cwvzipcode, ;
		           IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		           investor.ctaxid AS cwvtaxid, ;
		           CAST(MAX(suspense.nrevoil) AS N(13, 8)) AS nOilInt,;
		           CAST(MAX(suspense.nrevgas) AS N(13, 8)) AS nGasInt, ;
		           TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		           SUM(suspense.nOilRev) AS noilval, ;
		           SUM(suspense.nGasRev - ((suspense.nGather + suspense.nCompress) * lnMultiplier)) AS ngasval, ;
		           SUM(suspense.nothrev) AS nothval, ;
		           wells.cnra1 AS cnra, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           m.cTaxYear AS cTaxYear, ;
		           suspense.ctypeinv ;
		       FROM suspense ;
		       JOIN investor ;
		           ON suspense.cownerid = investor.cownerid ;
		       JOIN wells ;
		           ON suspense.cwellid = wells.cwellid ;
		       WHERE INLIST(suspense.ctypeinv, 'L', 'O') ;
		           AND suspense.lFlat = .F. ;
		           AND wells.cstate = lcState ;
		           AND &lcWhereS ;
		           AND (suspense.lManual = .F. ;
		             OR (suspense.lManual = .T. ;
		               AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                    FROM sysctl ;
		                    WHERE EMPTY(cVersion) ;
		                        AND cTypeclose = 'R'))) ;
		       INTO CURSOR tmpinv2 ;
		       ORDER BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           suspense.ctypeinv ;
		       GROUP BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           suspense.ctypeinv
		
		
		* Sum the interests by owner and well
		   SELECT  wells.cnra1 AS cnra, ;
		           wells.cwellid, ;
		           wellinv.cownerid, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           ctypeinv, ;
		           SUM(nrevoil) AS nOilInt, ;
		           SUM(nrevgas) AS nGasInt, ;
		           SUM(nrevoth) AS nOthInt, ;
		           m.cTaxYear AS cTaxYear ;
		       FROM wellinv ;
		       JOIN wells ;
		           ON wells.cwellid = wellinv.cwellid ;
		       INTO CURSOR tmproy READWRITE;
		       WHERE NOT lFlat ;
		           AND wells.cstate = lcState ;
		       ORDER BY cnra1,;
		           wells.cwellid,;
		           wellinv.cownerid,;
		           ctypeinv ;
		       GROUP BY cnra1,;
		           wells.cwellid,;
		           wellinv.cownerid,;
		           ctypeinv
		   INDEX ON cnra + cownerid + ctypeinv TAG welltype
		
		* Combine the two disbhist selects together into tempinv
		   SELECT tmpinv1
		   SCAN
		      SCATTER MEMVAR
		      SELECT tmpinv
		      LOCATE FOR cownerid = m.cownerid ;
		         AND cnra     = m.cnra ;
		         AND ctypeinv = m.ctypeinv
		      IF FOUND()
		         REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval, nothval WITH nothval + m.nothval
		      ELSE
		         INSERT INTO tmpinv FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		* Combine the suspense select into tmpinv
		   SELECT tmpinv2
		   SCAN
		      SCATTER MEMVAR
		      SELECT tmpinv
		      LOCATE FOR cownerid = m.cownerid ;
		         AND cnra     = m.cnra ;
		         AND cwellid  = m.cwellid ;
		         AND ctypeinv = m.ctypeinv
		      IF FOUND()
		         REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval, nothval WITH nothval + m.nothval
		      ELSE
		         INSERT INTO tmpinv FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		
		*  Look for flat-rate royalties
		   WAIT WINDOW NOWAIT 'Building Flat Rate Owners Totals'
		   SELECT  disbhist.cwellid, ;
		           disbhist.cownerid, ;
		           investor.cownname AS cRoyName, ;
		           investor.caddress1a AS cRoyAddr1, ;
		           investor.caddress1b AS cRoyAddr2, ;
		           investor.caddress1a AS cWVAddress, ;
		           investor.ccity1 AS cwvcity, ;
		           investor.cstate1 AS cwvstate, ;
		           investor.czip1 AS cwvzipcode, ;
		           IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		           investor.ctaxid AS cwvtaxid, ;
		           TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		           disbhist.ctypeinv, ;
		           SUM(disbhist.nflatrate) AS nflatrate, ;
		           wells.cnra1 AS cnra, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           m.cTaxYear AS cTaxYear, ;
		           disbhist.nflatfreq ;
		       FROM disbhist ;
		       JOIN investor ;
		           ON disbhist.cownerid = investor.cownerid ;
		       JOIN wells ;
		           ON disbhist.cwellid = wells.cwellid ;
		       WHERE &lcWhere1 ;
		           AND wells.cstate = lcState ;
		           AND disbhist.lFlat = .T. ;
		           AND disbhist.nflatrate # 0 ;
		           AND (disbhist.lManual = .F. ;
		             OR (disbhist.lManual = .T. ;
		               AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                    FROM sysctl ;
		                    WHERE EMPTY(cVersion) ;
		                        AND cTypeclose = 'R'))) ;
		       INTO CURSOR flatowner READWRITE ;
		       ORDER BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           disbhist.ctypeinv ;
		       GROUP BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           disbhist.ctypeinv
		
		   INDEX ON cwellid + cownerid + ctypeinv TAG welltype
		
		* Flat rates that went into suspense during the year
		   SELECT  disbhist.cwellid, ;
		           disbhist.cownerid, ;
		           investor.cownname AS cRoyName, ;
		           investor.caddress1a AS cRoyAddr1, ;
		           investor.caddress1b AS cRoyAddr2, ;
		           investor.caddress1a AS cWVAddress, ;
		           investor.ccity1 AS cwvcity, ;
		           investor.cstate1 AS cwvstate, ;
		           investor.czip1 AS cwvzipcode, ;
		           IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		           investor.ctaxid AS cwvtaxid, ;
		           TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		           disbhist.ctypeinv, ;
		           SUM(disbhist.nflatrate) AS nflatrate, ;
		           wells.cnra1 AS cnra, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           m.cTaxYear AS cTaxYear, ;
		           disbhist.nflatfreq ;
		       FROM disbhist ;
		       JOIN investor ;
		           ON disbhist.cownerid = investor.cownerid ;
		       JOIN wells ;
		           ON disbhist.cwellid = wells.cwellid ;
		       WHERE &lcWhere2 ;
		           AND wells.cstate = lcState ;
		           AND disbhist.lFlat = .T. ;
		           AND disbhist.nflatrate # 0 ;
		           AND (disbhist.lManual = .F. ;
		             OR (disbhist.lManual = .T. ;
		               AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                    FROM sysctl ;
		                    WHERE EMPTY(cVersion) ;
		                        AND cTypeclose = 'R'))) ;
		       INTO CURSOR flatowner1 READWRITE ;
		       ORDER BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           disbhist.ctypeinv ;
		       GROUP BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           disbhist.ctypeinv
		
		* Flat rates still in suspense processed during the year
		   SELECT  suspense.cwellid, ;
		           suspense.cownerid, ;
		           investor.cownname AS cRoyName, ;
		           investor.caddress1a AS cRoyAddr1, ;
		           investor.caddress1b AS cRoyAddr2, ;
		           investor.caddress1a AS cWVAddress, ;
		           investor.ccity1 AS cwvcity, ;
		           investor.cstate1 AS cwvstate, ;
		           investor.czip1 AS cwvzipcode, ;
		           IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		           investor.ctaxid AS cwvtaxid, ;
		           TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		           suspense.ctypeinv, ;
		           SUM(suspense.nflatrate) AS nflatrate, ;
		           wells.cnra1 AS cnra, ;
		           wells.cwellname, ;
		           wells.nwellcount, ;
		           m.cTaxYear AS cTaxYear, ;
		           suspense.nflatfreq ;
		       FROM suspense ;
		       JOIN investor ;
		           ON suspense.cownerid = investor.cownerid ;
		       JOIN wells ;
		           ON suspense.cwellid = wells.cwellid ;
		       WHERE &lcWhereS ;
		           AND wells.cstate = lcState ;
		           AND suspense.lFlat = .T. ;
		           AND (suspense.lManual = .F. ;
		             OR (suspense.lManual = .T. ;
		               AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                    FROM sysctl ;
		                    WHERE EMPTY(cVersion) ;
		                        AND cTypeclose = 'R'))) ;
		       INTO CURSOR flatowner2 ;
		       ORDER BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           suspense.ctypeinv ;
		       GROUP BY wells.cnra1,;
		           wells.cwellid,;
		           investor.cownname,;
		           investor.cownerid,;
		           suspense.ctypeinv
		
		   WAIT WINDOW NOWAIT 'Building Working Interest Owners Totals'
		   IF NOT llUseProducer_for_Working
		      SELECT  disbhist.cwellid, ;
		              disbhist.cownerid AS cownerid, ;
		              investor.cownname AS cRoyName, ;
		              investor.caddress1a AS cRoyAddr1, ;
		              investor.caddress1b AS cRoyAddr2, ;
		              investor.caddress1a AS cWVAddress, ;
		              investor.ccity1 AS cwvcity, ;
		              investor.cstate1 AS cwvstate, ;
		              investor.czip1 AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              investor.ctaxid AS cwvtaxid, ;
		              ALLTRIM(ccity1) + ' ' + cstate1 + ' ' + czip1 AS cRoyAddr3, ;
		              CAST(AVG(ownpcts.nrevoil) AS N(13, 8))AS nOilInt,;
		              CAST(AVG(ownpcts.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              SUM(disbhist.nOilRev) AS noilval, ;
		              wells.cnra1 AS cnra, ;
		              wells.cwellname, ;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval, ;
		              SUM(disbhist.nothrev) AS nothval ;
		          FROM disbhist ;
		          JOIN ownpcts ;
		              ON disbhist.ciddisb = ownpcts.ciddisb ;
		          JOIN wells ;
		              ON disbhist.cwellid = wells.cwellid  ;
		          JOIN investor ;
		              ON investor.cownerid = disbhist.cownerid ;
		          WHERE disbhist.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		              AND &lcWhere1 ;
		              AND (disbhist.lManual = .F. ;
		                OR (disbhist.lManual = .T. ;
		                  AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		                  (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                       FROM sysctl ;
		                       WHERE EMPTY(cVersion) ;
		                           AND cTypeclose = 'R'))) ;
		          INTO CURSOR tmpwrk READWRITE ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid,;
		              investor.cownname,;
		              investor.cownerid;
		          GROUP BY wells.cnra1,;
		              wells.cwellid,;
		              investor.cownname,;
		              investor.cownerid
		
		      SELECT  disbhist.cwellid, ;
		              disbhist.cownerid AS cownerid, ;
		              investor.cownname AS cRoyName, ;
		              investor.caddress1a AS cRoyAddr1, ;
		              investor.caddress1b AS cRoyAddr2, ;
		              investor.caddress1a AS cWVAddress, ;
		              investor.ccity1 AS cwvcity, ;
		              investor.cstate1 AS cwvstate, ;
		              investor.czip1 AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              investor.ctaxid AS cwvtaxid, ;
		              wells.cnra1 AS cnra, ;
		              wells.cwellname, ;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              ALLTRIM(ccity1) + ' ' + cstate1 + ' ' + czip1 AS cRoyAddr3, ;
		              CAST(AVG(ownpcts.nrevoil) AS N(13, 8))AS nOilInt,;
		              CAST(AVG(ownpcts.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              SUM(disbhist.nOilRev) AS noilval, ;
		              SUM(disbhist.nothrev) AS nothval, ;
		              SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		          FROM disbhist ;
		          JOIN ownpcts ;
		              ON disbhist.ciddisb = ownpcts.ciddisb ;
		          JOIN wells ;
		              ON disbhist.cwellid = wells.cwellid  ;
		          JOIN investor ;
		              ON investor.cownerid = disbhist.cownerid ;
		          WHERE disbhist.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		              AND &lcWhere2 ;
		              AND (disbhist.lManual = .F. ;
		                OR (disbhist.lManual = .T. ;
		                  AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		                  (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                       FROM sysctl ;
		                       WHERE EMPTY(cVersion) ;
		                           AND cTypeclose = 'R'))) ;
		          INTO CURSOR tmpwrk1 READWRITE ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid,;
		              investor.cownname,;
		              investor.cownerid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid,;
		              investor.cownname,;
		              investor.cownerid
		
		
		      SELECT  suspense.cwellid, ;
		              suspense.cownerid AS cownerid, ;
		              investor.cownname AS cRoyName, ;
		              investor.caddress1a AS cRoyAddr1, ;
		              investor.caddress1b AS cRoyAddr2, ;
		              investor.caddress1a AS cWVAddress, ;
		              investor.ccity1 AS cwvcity, ;
		              investor.cstate1 AS cwvstate, ;
		              investor.czip1 AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              investor.ctaxid AS cwvtaxid, ;
		              ALLTRIM(ccity1) + ' ' + cstate1 + ' ' + czip1 AS cRoyAddr3, ;
		              CAST(AVG(suspense.nrevoil) AS N(13, 8))AS nOilInt,;
		              CAST(AVG(suspense.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              SUM(suspense.nOilRev) AS noilval, ;
		              SUM(suspense.nothrev) AS nothval, ;
		              wells.cnra1 AS cnra, ;
		              wells.cwellname, ;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              SUM(suspense.nGasRev - ((suspense.nGather + suspense.nCompress) * lnMultiplier)) AS ngasval ;
		          FROM suspense ;
		          JOIN wells ;
		              ON wells.cwellid = suspense.cwellid ;
		          JOIN investor ;
		              ON investor.cownerid = suspense.cownerid ;
		          WHERE suspense.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		              AND &lcWhereS ;
		              AND (suspense.lManual = .F. ;
		                OR (suspense.lManual = .T. ;
		                  AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		                  (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                       FROM sysctl ;
		                       WHERE EMPTY(cVersion) ;
		                           AND cTypeclose = 'R'))) ;
		          INTO CURSOR tmpwrk2 ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid,;
		              investor.cownname,;
		              investor.cownerid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid,;
		              investor.cownname,;
		              investor.cownerid
		
		      SELECT  wells.cnra1 AS cnra,;
		              wellinv.cownerid AS cownerid, ;
		              wells.cwellid, ;
		              wells.cwellname,;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              CAST(SUM(wellinv.nrevoil) AS N(13, 8)) AS nOilInt, ;
		              CAST(SUM(wellinv.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              CAST(SUM(wellinv.nrevoth) AS N(13, 8)) AS nOthInt ;
		          FROM wellinv ;
		          JOIN wells ;
		              ON wellinv.cwellid = wells.cwellid ;
		          WHERE wellinv.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		          INTO CURSOR tmpwork ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid,;
		              wellinv.cownerid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid,;
		              wellinv.cownerid
		
		      INDEX ON cnra TAG nra
		
		   ELSE
		
		      SELECT  disbhist.cwellid, ;
		              'WORKINT' AS cownerid, ;
		              lcWorkInt AS cRoyName, ;
		              m.caddress AS cRoyAddr1, ;
		              SPACE(40) AS cRoyAddr2, ;
		              m.ctaxid AS cwvtaxid, ;
		              m.caddress AS cWVAddress, ;
		              m.ccity AS cwvcity, ;
		              m.goapp.cstate AS cwvstate, ;
		              m.czip AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              ALLTRIM(m.ccity) + ' ' + m.goapp.cstate + ' ' + m.czip AS cRoyAddr3, ;
		              CAST(AVG(ownpcts.nrevoil) AS N(13, 8))AS nOilInt,;
		              CAST(AVG(ownpcts.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              SUM(disbhist.nOilRev) AS noilval, ;
		              SUM(disbhist.nothrev) AS nothval, ;
		              wells.cnra1 AS cnra, ;
		              wells.cwellname, ;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		          FROM disbhist ;
		          JOIN ownpcts ;
		              ON disbhist.ciddisb = ownpcts.ciddisb ;
		          JOIN wells ;
		              ON disbhist.cwellid = wells.cwellid  ;
		          JOIN investor ;
		              ON investor.cownerid = disbhist.cownerid ;
		          WHERE disbhist.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		              AND &lcWhere1 ;
		              AND (disbhist.lManual = .F. ;
		                OR (disbhist.lManual = .T. ;
		                  AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		                  (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                       FROM sysctl ;
		                       WHERE EMPTY(cVersion) ;
		                           AND cTypeclose = 'R'))) ;
		          INTO CURSOR tmpwrk READWRITE ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid
		
		      SELECT  disbhist.cwellid, ;
		              'WORKINT' AS cownerid, ;
		              lcWorkInt AS cRoyName, ;
		              m.caddress AS cRoyAddr1, ;
		              SPACE(40) AS cRoyAddr2, ;
		              m.ctaxid AS cwvtaxid, ;
		              m.caddress AS cWVAddress, ;
		              m.ccity AS cwvcity, ;
		              m.goapp.cstate AS cwvstate, ;
		              m.czip AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              wells.cnra1 AS cnra, ;
		              wells.nwellcount, ;
		              wells.cwellname, ;
		              m.cTaxYear AS cTaxYear, ;
		              ALLTRIM(m.ccity) + ' ' + m.goapp.cstate + ' ' + m.czip AS cRoyAddr3, ;
		              CAST(AVG(ownpcts.nrevoil) AS N(13, 8))AS nOilInt,;
		              CAST(AVG(ownpcts.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              SUM(disbhist.nOilRev) AS noilval, ;
		              SUM(disbhist.nothrev) AS nothval, ;
		              SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		          FROM disbhist ;
		          JOIN ownpcts ;
		              ON disbhist.ciddisb = ownpcts.ciddisb ;
		          JOIN wells ;
		              ON disbhist.cwellid = wells.cwellid  ;
		          JOIN investor ;
		              ON investor.cownerid = disbhist.cownerid ;
		          WHERE disbhist.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		              AND &lcWhere2 ;
		              AND (disbhist.lManual = .F. ;
		                OR (disbhist.lManual = .T. ;
		                  AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		                  (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                       FROM sysctl ;
		                       WHERE EMPTY(cVersion) ;
		                           AND cTypeclose = 'R'))) ;
		          INTO CURSOR tmpwrk1 READWRITE ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid
		
		
		      SELECT  suspense.cwellid, ;
		              'WORKINT' AS cownerid, ;
		              lcWorkInt AS cRoyName, ;
		              m.caddress AS cRoyAddr1, ;
		              SPACE(40) AS cRoyAddr2, ;
		              m.ctaxid AS cwvtaxid, ;
		              m.caddress AS cWVAddress, ;
		              m.ccity AS cwvcity, ;
		              m.goapp.cstate AS cwvstate, ;
		              m.czip AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              ALLTRIM(m.ccity) + ' ' + m.goapp.cstate + ' ' + m.czip AS cRoyAddr3, ;
		              CAST(AVG(suspense.nrevoil) AS N(13, 8))AS nOilInt,;
		              CAST(AVG(suspense.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              SUM(suspense.nOilRev) AS noilval, ;
		              SUM(suspense.nothrev) AS nothval, ;
		              wells.cnra1 AS cnra, ;
		              wells.cwellname, ;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              SUM(suspense.nGasRev - ((suspense.nGather + suspense.nCompress) * lnMultiplier)) AS ngasval ;
		          FROM suspense ;
		          JOIN wells ;
		              ON wells.cwellid = suspense.cwellid ;
		          JOIN investor ;
		              ON investor.cownerid = suspense.cownerid ;
		          WHERE suspense.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		              AND &lcWhereS ;
		              AND (suspense.lManual = .F. ;
		                OR (suspense.lManual = .T. ;
		                  AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		                  (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		                       FROM sysctl ;
		                       WHERE EMPTY(cVersion) ;
		                           AND cTypeclose = 'R'))) ;
		          INTO CURSOR tmpwrk2 ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid
		
		      INDEX ON cnra TAG nra
		
		
		      SELECT  wells.cnra1 AS cnra,;
		              wells.cwellid,;
		              'WORKINT' AS cownerid, ;
		              wells.cwellname,;
		              wells.nwellcount, ;
		              m.cTaxYear AS cTaxYear, ;
		              CAST(SUM(wellinv.nrevoil) AS N(13, 8)) AS nOilInt, ;
		              CAST(SUM(wellinv.nrevgas) AS N(13, 8)) AS nGasInt, ;
		              CAST(SUM(wellinv.nrevoth) AS N(13, 8)) AS nOthInt ;
		          FROM wellinv ;
		          JOIN wells ;
		              ON wellinv.cwellid = wells.cwellid ;
		          WHERE wellinv.ctypeinv = 'W' ;
		              AND wells.cstate = lcState ;
		          INTO CURSOR tmpwork ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid
		
		      INDEX ON cnra TAG nra
		
		   ENDIF
		
		
		   SELECT tmpwrk1
		   SCAN
		      SCATTER MEMVAR
		      SELECT tmpwrk
		      LOCATE FOR cownerid = m.cownerid ;
		         AND cnra     = m.cnra ;
		         AND cwellid  = m.cwellid
		      IF FOUND()
		         REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval, nothval WITH nothval + m.nothval
		      ELSE
		         INSERT INTO tmpwrk FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT tmpwrk2
		   SCAN
		      SCATTER MEMVAR
		      SELECT tmpwrk
		      LOCATE FOR cownerid = m.cownerid ;
		         AND cwellid      = m.cwellid ;
		         AND cnra     = m.cnra
		      IF FOUND()
		         REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval, nothval WITH nothval + m.nothval
		      ELSE
		         INSERT INTO tmpwrk FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   WAIT CLEAR
		
		   SELECT tempann
		   SCAN
		      SCATTER MEMVAR
		
		      m.cnra = PADR(ALLTRIM(m.cnra), 15, ' ')
		
		      oProgress.SetProgressMessage('Preparing Return for well: ' + m.cwellid)
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		
		* Change interests to decimal interests
		      IF RECCOUNT('tmpinv') > 0
		
		         SELECT tmpinv
		         SCAN FOR cnra == m.cnra AND cwellid = m.cwellid
		            SCATTER MEMVAR
		
		            m.nOilInt = nOilInt / 100
		            m.nGasInt = nGasInt / 100
		            m.nOthInt = nOthInt / 100
		
		
		            SELE tmproy
		            LOCATE FOR cnra = m.cnra AND ;
		               cownerid = m.cownerid AND ;
		               ctypeinv = m.ctypeinv
		            IF FOUND()
		               m.nOilInt = nOilInt / 100
		               m.nGasInt = nGasInt / 100
		               m.nOthInt = nOthInt / 100
		            ENDIF
		            IF m.ctypeinv = 'L'
		               m.ctypeinv = 'RI'
		            ELSE
		               m.ctypeinv = 'ORRI*'
		               IF llOverride
		                  m.cRoyName = 'Override Interest'
		               ENDIF
		            ENDIF
		            m.ntotalval = ROUND(m.ngasval + m.noilval + m.nothval, 0)
		            m.cidstown  = GetNextPK('FORM6S')
		            m.cstate    = lcState
		            INSERT INTO temp6s FROM MEMVAR
		         ENDSCAN
		      ENDIF
		
		* Insert flat rate owners into form6s
		      SELECT flatowner1
		      SCAN FOR cnra == m.cnra AND cwellid = m.cwellid
		         SCATTER MEMVAR
		         SELECT flatowner
		         LOCATE FOR cnra = m.cnra AND ;
		            cownerid = m.cownerid AND ;
		            ctypeinv = m.ctypeinv
		         IF FOUND()
		            REPLACE nflatrate WITH nflatrate + m.nflatrate
		         ELSE
		            INSERT INTO flatowner FROM MEMVAR
		         ENDIF
		      ENDSCAN
		      SELECT flatowner2
		      SCAN FOR cnra == m.cnra AND cwellid = m.cwellid
		         SCATTER MEMVAR
		         SELECT flatowner
		         LOCATE FOR cnra = m.cnra AND ;
		            cownerid = m.cownerid AND ;
		            ctypeinv = m.ctypeinv
		         IF FOUND()
		            REPLACE nflatrate WITH nflatrate + m.nflatrate
		         ELSE
		            INSERT INTO flatowner FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      IF RECCOUNT('flatowner') > 0
		         lnMax     = lnMax + RECCOUNT('flatowner')
		         SELECT flatowner
		         SCAN FOR cnra == m.cnra AND cwellid = m.cwellid
		            SCATTER MEMVAR
		            m.ctypeinv  = 'FR'
		            m.nOilInt   = 0
		            m.nGasInt   = 0
		            m.noilval   = 0
		            m.ngasval   = 0
		            m.ntotalval = m.nflatrate
		
		            swselect('Temp6s')
		            IF SEEK(m.cownerid + m.cwellid)
		               REPLACE ntotalval WITH ROUND(ntotalval + m.ntotalval, 0)
		            ELSE
		               m.cidstown   = GetNextPK('FORM6S')
		               m.cwellstate = lcState
		               INSERT INTO temp6s FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		         SELECT  cwellid,;
		                 SUM(ntotalval) AS nflattotal ;
		             FROM temp6s ;
		             WHERE ctypeinv = 'FR' ;
		                 AND cnra = m.cnra ;
		             INTO CURSOR tempflat ;
		             ORDER BY cwellid ;
		             GROUP BY cwellid
		      ENDIF
		
		* Reset variable, since it's getting assigned to the state the report is being build for above - BH 10/09/2008
		      m.cstate = m.goapp.cstate
		
		      IF RECCOUNT('tmpwrk') > 0
		         SELECT tmpwrk
		         SCAN FOR cnra = m.cnra AND cwellid = m.cwellid
		            SCATTER MEMVAR
		
		            m.nOilInt = nOilInt / 100
		            m.nGasInt = nGasInt / 100
		
		            m.ctypeinv = 'WI'
		            SELE tmpwork
		            IF NOT llUseProducer_for_Working
		               LOCATE FOR cnra = m.cnra ;
		                  AND cownerid = m.cownerid AND cwellid = m.cwellid
		               IF FOUND()
		                  m.nOilInt = nOilInt / 100
		                  m.nGasInt = nGasInt / 100
		                  m.nOthInt = nOthInt / 100
		               ELSE
		                  STORE 0 TO m.nOilInt, m.nGasInt
		               ENDIF
		            ELSE
		               IF SEEK(m.cnra)
		                  m.nOilInt = nOilInt / 100
		                  m.nGasInt = nGasInt / 100
		                  m.nOthInt = nOthInt / 100
		               ELSE
		                  STORE 0 TO m.nOilInt, m.nGasInt
		               ENDIF
		            ENDIF
		            m.ntotalval  = ROUND(m.ngasval + m.noilval + m.nothval, 0)
		            m.cidstown   = GetNextPK('FORM6S')
		            m.cwellstate = lcState
		            INSERT INTO temp6s FROM MEMVAR
		         ENDSCAN  && tmpwrk
		      ENDIF
		
		      SELECT  wellinv.cwellid, ;
		              wells.cwellname, ;
		              wellinv.ctypeinv, ;
		              wells.cnra1 AS cnra, ;
		              SUM(wellinv.nrevgas / 100) AS nGasInt, ;
		              SUM(wellinv.nrevoil / 100) AS nOilInt, ;
		              SUM(wellinv.nrevoth / 100) AS nOthInt, ;
		              wellinv.cownerid AS cownerid, ;
		              investor.cownname AS cRoyName, ;
		              investor.caddress1a AS cRoyAddr1, ;
		              investor.caddress1b AS cRoyAddr2, ;
		              ALLTRIM(ccity1) + ' ' + cstate1 + ' ' + czip1 AS cRoyAddr3, ;
		              investor.caddress1a AS cWVAddress, ;
		              investor.ccity1 AS cwvcity, ;
		              investor.cstate1 AS cwvstate, ;
		              investor.czip1 AS cwvzipcode, ;
		              IIF(EMPTY(investor.ccountry1), 'US', investor.ccountry1)  AS ccountry, ;
		              investor.ctaxid AS cwvtaxid, ;
		              0 AS ntotalval ;
		          FROM wellinv ;
		          JOIN wells;
		              ON wells.cwellid = wellinv.cwellid ;
		          JOIN investor;
		              ON investor.cownerid = wellinv.cownerid ;
		          WHERE wells.cnra1 = m.cnra;
		              AND wellinv.cwellid = m.cwellid ;
		          INTO CURSOR tempowners1 READWRITE  ;
		          ORDER BY wells.cnra1,;
		              wells.cwellid,;
		              cRoyName,;
		              wellinv.ctypeinv ;
		          GROUP BY wells.cnra1,;
		              wells.cwellid,;
		              cRoyName,;
		              wellinv.ctypeinv
		
		      SELECT tempowners1
		      IF llUseProducer_for_Working
		         REPLACE cownerid WITH 'WORKINT', cRoyName WITH lcWorkInt FOR ctypeinv = 'W'
		      ENDIF
		
		      SELECT  cwellid, ;
		              cwellname, ;
		              ctypeinv, ;
		              cnra, ;
		              SUM(nGasInt) AS nGasInt, ;
		              SUM(nOilInt) AS nOilInt, ;
		              SUM(nOthInt) AS nOthInt, ;
		              cownerid, ;
		              cRoyName, ;
		              cRoyAddr1, ;
		              cRoyAddr2, ;
		              cRoyAddr3, ;
		              cWVAddress, ;
		              cWVCity, ;
		              cWVState, ;
		              cWVZipCode, ;
		              0 AS ntotalval ;
		          FROM tempowners1 ;
		          INTO CURSOR tempowners ;
		          ORDER BY cnra,;
		              cwellid,;
		              cRoyName,;
		              ctypeinv ;
		          GROUP BY cnra,;
		              cwellid,;
		              cRoyName,;
		              ctypeinv
		
		      SELECT tempowners
		      SCAN
		         SCATTER MEMVAR
		         m.cwellstate = 'WV'
		
		         DO CASE
		            CASE m.ctypeinv = 'W'
		               m.ctypeinv = 'WI'
		            CASE m.ctypeinv = 'L'
		               m.ctypeinv = 'RI'
		            CASE m.ctypeinv = 'O'
		               m.ctypeinv = 'ORRI'
		         ENDCASE
		
		         SELECT temp6s
		         LOCATE FOR cnra = m.cnra ;
		            AND cownerid = m.cownerid ;
		            AND cwellid  = m.cwellid ;
		            AND ctypeinv = m.ctypeinv
		         IF NOT FOUND()
		            m.cidstown = GetNextPK('FORM6S')
		            INSERT INTO temp6s FROM MEMVAR
		         ENDIF
		      ENDSCAN
		   ENDSCAN &&tempann
		
		   oProgress.CloseProgress()
		
		   SELECT temp6s
		   SCAN
		      REPLACE ntotalval WITH ROUND(ntotalval, 0)
		
		      IF nOilInt = 0
		         REPLACE nOilInt WITH nGasInt
		      ENDIF
		
		      IF nGasInt = 0
		         REPLACE nGasInt WITH nOilInt
		      ENDIF
		
		   ENDSCAN
		
		   lnMax     = RECCOUNT('temp6s')
		   oProgress = THISFORM.oMessage.ProgressBarEx('Inserting Owner Records...')
		   oProgress.SetProgressRange(0, lnMax)
		   lnOwners = 0
		
		   SELECT form6s
		   SET ORDER TO WVKEY
		
		   SELECT temp6s
		   SCAN FOR nOilInt # 0 OR nGasInt # 0 OR ntotalval # 0
		      SCATTER MEMVAR
		      oProgress.SetProgressMessage('Well: ' + m.cwellid)
		      oProgress.UpdateProgress(lnOwners)
		      lnOwners = lnOwners + 1
		
		      oName          = SplitNames(m.cRoyName)
		      m.cWVFirstName = oName.cFirstName
		      m.cWVLastName  = oName.cLastName
		
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(m.cwellid)
		         m.nwellcount = nwellcount
		         IF m.nwellcount < 1
		            m.nwellcount = 1
		         ENDIF
		         m.ntotalval = ROUND(m.ntotalval / m.nwellcount, 0)
		         FOR lnX = 1 TO m.nwellcount
		            DO CASE
		               CASE lnX = 1
		                  m.cnra = wells.cnra1
		               CASE lnX = 2
		                  m.cnra = wells.cnra2
		               CASE lnX = 3
		                  m.cnra = wells.cnra3
		               CASE lnX = 4
		                  m.cnra = wells.cnra4
		               CASE lnX = 5
		                  m.cnra = wells.cnra5
		               CASE lnX = 6
		                  m.cnra = wells.cnra6
		            ENDCASE
		            m.cidstown = GetNextPK('FORM6S')
		            SELECT form6s
		            IF SEEK(m.cYear + m.cownerid + m.cnra + m.ctypeinv)
		               * Do Nothing
		            ELSE 
		               SELECT annprodtemp
		               LOCATE FOR cwellid = m.cwellid
		               IF FOUND()
		                  INSERT INTO form6s FROM MEMVAR
		               ENDIF
		            ENDIF
		         ENDFOR
		      ENDIF
		   ENDSCAN
		
		   WAIT WINDOW NOWAIT 'Checking Interests...'
		* Check to make sure the interests add up correctly
		   SELECT  cnra, ;
		           SUM(nOilInt) AS oilpct, ;
		           SUM(nGasInt) AS gaspct, ;
		           SUM(nOthInt) AS nothpct, ;
		           0.00000000 AS ndiffoil, ;
		           0.00000000 AS ndiffgas, ;
		           0.00000000 AS ndiffoth ;
		       FROM temp6s ;
		       INTO CURSOR temppct1 READWRITE ;
		       ORDER BY cnra,;
		           cwellid ;
		       GROUP BY cnra,;
		           cwellid
		
		   SELECT temppct1
		   SCAN
		      SCATTER MEMVAR
		      IF m.oilpct > 1
		         m.ndiff = m.oilpct - 1
		         REPLACE ndiffoil WITH m.ndiff
		      ENDIF
		      IF m.gaspct > 1
		         m.ndiff = m.gaspct - 1
		         REPLACE ndiffgas WITH m.ndiff
		      ENDIF
		   ENDSCAN
		
		   SELECT temppct1
		   SCAN FOR ndiffgas <> 0 OR ndiffoil <> 0
		      SCATTER MEMVAR
		
		      IF m.ndiffgas <> 0
		         SELECT temp6s
		         LOCATE FOR cnra = m.cnra AND cwellid = m.cwellid AND ctypeinv = 'WI'
		         IF FOUND()
		            REPLACE nGasInt WITH nGasInt - m.ndiffgas
		         ENDIF
		      ENDIF
		
		      IF m.ndiffoil <> 0
		         SELECT temp6s
		         LOCATE FOR cnra = m.cnra AND cwellid = m.cwellid AND ctypeinv = 'WI'
		         IF FOUND()
		            REPLACE nOilInt WITH nOilInt - m.ndiffoil
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   WAIT CLEAR
		
		   WAIT WINDOW NOWAIT 'Checking totals...'
		
		* Check for mismatching totals and fix
		   SELECT  cnra,;
		           cwellid,;
		           SUM(noilinc + ngasinc + nothinc) AS nwelltot,;
		           000000000.00 AS nowntot,;
		           000000000.00 AS ndiff ;
		       FROM tempann1 ;
		       INTO CURSOR tempdiff1 READWRITE ;
		       ORDER BY cnra ;
		       GROUP BY cnra
		
		   SELECT  cnra,;
		           cwellid,;
		           SUM(ntotalval) AS nval ;
		       FROM form6s WITH (BUFFERING =.T.) ;
		       WHERE cYear = m.cYear ;
		       INTO CURSOR tempdiff2 ;
		       ORDER BY cnra ;
		       GROUP BY cnra
		
		   SELECT tempdiff2
		   SCAN
		      SELECT tempdiff1
		      LOCATE FOR cnra == tempdiff2.cnra AND cwellid = tempdiff2.cwellid AND cYear = m.cYear
		      IF FOUND()
		         REPLACE nowntot WITH tempdiff2.nval
		         REPLACE ndiff WITH nwelltot - nowntot
		      ENDIF
		   ENDSCAN
		
		   SELECT * FROM tempdiff1 INTO CURSOR tempdiff WHERE ndiff # 0
		   SCAN
		      SELECT annprod
		      LOCATE FOR cnra = tempdiff.cnra AND cwellid = tempdiff.cwellid AND cYear = m.cYear
		      IF FOUND()
		         IF ngasinc # 0
		            REPLACE ngasinc WITH ngasinc - tempdiff.ndiff
		         ELSE
		            IF noilinc # 0
		               REPLACE noilinc WITH noilinc - tempdiff.ndiff
		            ELSE
		               IF nothinc # 0
		                  REPLACE nothinc WITH nothinc - tempdiff.ndiff
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   WAIT CLEAR
		   oProgress.CloseProgress()
		   WAIT CLEAR
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Build_WV_Owners', loError.LINENO, 'Annual WV Return', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE Init
		LPARA tcState
		LOCAL lnX, lnY
		DODEFAULT()
		
		tcState = 'WV'
		
		*  If you're building it during the first 6 months of the year,
		*  you're probably doing it for the previous year.
		IF BETWEEN(MONTH(DATE()), 1, 6)
		   THISFORM.txtcYear.VALUE = STR(YEAR(DATE()) - 1, 4)
		ELSE
		   THISFORM.txtcYear.VALUE = STR(YEAR(DATE()), 4)
		ENDIF
		
		*
		*  Get info about the state reports that are on disk
		*
		THISFORM.cState = tcState
		
		THISFORM.HELPCONTEXTID             = 622
		THISFORM.chkusEOVERRIDE.VISIBLE    = .T.
		THISFORM.chkusePRODUCER.VISIBLE    = .T.
		
		*  This is always done in the following year, so just set it back a year
		THISFORM.txtcYear.SET('value', ALLTRIM(STR(YEAR(DATE()) - 1)))
		
		
		THIS.oRegistry = FindGlobalObject('cmRegistry')
		THIS.oMessage  = FindGlobalObject('cmMessage')
		
		
	ENDPROC

	PROCEDURE cmdBuild.Click
		
		thisform.buildfile()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE opgYear.Init
		IF DODEFAULT()
		   THIS.VALUE = 1
		ENDIF
		
	ENDPROC

ENDDEFINE
